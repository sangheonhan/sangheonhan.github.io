[{"content":"언제부터인지 Ubuntu 업그레이드 이후 Gnome Terminal에서 Powerline 폰트가 이상하게 나오는 문제를 발견했습니다. 폰트의 높이가 위아래로 늘어나는 현상인데, 이로 인해 폰트가 깨져서 보였습니다. 이 현상의 원인을 찾아보려고 여러 방법을 시도했지만, 결국에는 해결하지 못하고 Ubuntu 20.04로 시스템을 복구하였습니다.\n하지만 Ubuntu 22.04를 사용하면서 다시 이 문제가 발생하였고, 여러 시도와 검색 끝에 문제의 원인을 찾아냈습니다. 원인은 바로 Gnome Terminal에서 사용되는 VTE Terminal Widget Library였습니다.\nVTE Library는 사용자의 환경이 CJK(Chinese, Japanese, Korean)인 경우, 폰트의 높이 값을 무시하고 강제적으로 높이를 높게 설정합니다. 이는 CJK 문자의 경우 알파벳보다 높이를 높게 설정하는 것이 가독성에 유리하기 때문으로 보입니다만, Powerline이나 Nerd Font 같은 특수 폰트에는 부정적인 영향을 주어 폰트가 깨지는 문제를 유발합니다.\n이 문제를 해결하기 위해서는 VTE Library 코드를 수정한 후에, Gnome Terminal을 다시 컴파일해야 합니다. 하지만 매번 패치 후 컴파일을 하는 건 번거로우므로 그다지 편리한 해결방법이라고 볼 수 없습니다.\n그래서 다른 간단한 방법을 찾아보았고, 시스템의 locale 설정을 변경함으로써 문제를 해결하였습니다. 바로 LANG 환경 변수를 en_US.UTF-8로 설정하는 것입니다. 이 방법은 VTE가 폰트 높이를 강제적으로 변경하지 않도록 만들어, Powerline 폰트가 깨지는 문제를 방지합니다.\n아래는 이 방법을 적용하는 방법입니다.\nsudo 권한으로 /etc/default/locale 파일을 열습니다.\n1 sudo nano /etc/default/locale LANG 변수를 en_US.UTF-8로 설정한 후 파일을 저장하고 종료합니다.\n1 LANG=en_US.UTF-8 리부팅합니다.\n이제 터미널에서 Powerline 폰트를 사용하면서도 깨짐 현상 없이 편안하게 작업할 수 있습니다. 물론 이 방법은 한글 환경에서 행의 높이를 줄이는 방법이므로 가독성이 조금 떨어질 수 있습니다. 하지만 터미널 환경에서는 대부분 알파벳을 읽기 때문에 크게 불편한 점을 느끼진 못 했습니다.\n","permalink":"https://sangheonhan.github.io/gnome-terminal%EC%97%90%EC%84%9C-powerline-%ED%8F%B0%ED%8A%B8-%EA%B9%A8%EC%A7%90-%ED%98%84%EC%83%81-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/","summary":"언제부터인지 Ubuntu 업그레이드 이후 Gnome Terminal에서 Powerline 폰트가 이상하게 나오는 문제를 발견했습니다. 폰트의 높이가 위아래로 늘어나는 현상인데, 이로 인해 폰","title":"Gnome Terminal에서 Powerline 폰트 깨짐 현상 해결하기"},{"content":"macOS에서 특정 IP만 ssh 연결을 허용하기 위해서는 방화벽이 아닌 sshd 설정을 통해 접근을 허용해야 합니다.\n/etc/ssh/sshd_config.d/ 디렉토리 안에 적절한 파일(여기서는 900-allowuser.conf)을 만들어서 허용하려고 하는 사용자와 접근 IP를 적어주면 됩니다.\n1 sudo vi /etc/ssh/sshd_config.d/900-allowuser.conf 1 AllowUsers foo@10.0.0.10 bar@10.0.0.20 파일 저정한 뒤에 시스템 환경설정 - 공유 - 원격 로그인 항목을 껐다 켜거나, 명령행에서 다음 명령을 실행하는 것으로 sshd를 재시작 합니다.\n1 2 sudo launchctl unload /System/Library/LaunchDaemons/ssh.plist sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist ","permalink":"https://sangheonhan.github.io/macos-%ED%8A%B9%EC%A0%95-ip%EC%97%90%EC%84%9C%EB%A7%8C-ssh-%EC%A0%91%EC%86%8D%EC%9D%84-%ED%97%88%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/","summary":"macOS에서 특정 IP만 ssh 연결을 허용하기 위해서는 방화벽이 아닌 sshd 설정을 통해 접근을 허용해야 합니다. /etc/ssh/sshd_config.d/ 디렉토리 안에 적절한 파일(여기서는 900-al","title":"MacOS: 특정 IP에서만 SSH 접속을 허용하는 방법"},{"content":"유니버설 링크(Universal Links) 앱에서 유니버설 링크를 지원하기 위해서는 apple-app-site-association(AASA) 파일을 작성해서 웹 서버에 올려두는 작업이 필요합니다.\nApple JSON Metadata file iOS 12 이전 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;applinks\u0026#34;: { \u0026#34;apps\u0026#34;: [], \u0026#34;details\u0026#34;: [ { \u0026#34;appID\u0026#34;: \u0026#34;\u0026lt;TEAM_DEVELOPER_ID\u0026gt;.\u0026lt;BUNDLE_IDENTIFIER\u0026gt;\u0026#34;, \u0026#34;paths\u0026#34;: [\u0026#34;*\u0026#34;] }, { \u0026#34;appID\u0026#34;: \u0026#34;\u0026lt;TEAM_DEVELOPER_ID\u0026gt;.\u0026lt;BUNDLE_IDENTIFIER\u0026gt;\u0026#34;, \u0026#34;paths\u0026#34;: [\u0026#34;/articles/*\u0026#34;] }, { \u0026#34;appID\u0026#34;: \u0026#34;\u0026lt;TEAM_DEVELOPER_ID\u0026gt;.\u0026lt;ANOTHER_APP_BUNDLE_IDENTIFIER\u0026gt;\u0026#34;, \u0026#34;paths\u0026#34;: [\u0026#34;/blog/*\u0026#34;, \u0026#34;/articles/*\u0026#34;] } ] } } 주의 사항 apps는 빈 배열이어야 합니다. 파일 이름은 json 확장자가 없는 apple-app-site-association이어야 합니다. 파일 위치는 http://foobar.com/apple-app-site-association입니다. iOS 13 이후 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { \u0026#34;applinks\u0026#34;: { \u0026#34;details\u0026#34;: [ { \u0026#34;appIDs\u0026#34;: [ \u0026#34;ABCDE12345.com.example.app\u0026#34;, \u0026#34;ABCDE12345.com.example.app2\u0026#34; ], \u0026#34;components\u0026#34;: [ { \u0026#34;#\u0026#34;: \u0026#34;no_universal_links\u0026#34;, \u0026#34;exclude\u0026#34;: true, \u0026#34;comment\u0026#34;: \u0026#34;Matches any URL whose fragment equals no_universal_links and instructs the system not to open it as a universal link\u0026#34; }, { \u0026#34;/\u0026#34;: \u0026#34;/buy/*\u0026#34;, \u0026#34;comment\u0026#34;: \u0026#34;Matches any URL whose path starts with /buy/\u0026#34; }, { \u0026#34;/\u0026#34;: \u0026#34;/help/website/*\u0026#34;, \u0026#34;exclude\u0026#34;: true, \u0026#34;comment\u0026#34;: \u0026#34;Matches any URL whose path starts with /help/website/ and instructs the system not to open it as a universal link\u0026#34; } { \u0026#34;/\u0026#34;: \u0026#34;/help/*\u0026#34;, \u0026#34;?\u0026#34;: { \u0026#34;articleNumber\u0026#34;: \u0026#34;????\u0026#34; }, \u0026#34;comment\u0026#34;: \u0026#34;Matches any URL whose path starts with /help/ and which has a query item with name \u0026#39;articleNumber\u0026#39; and a value of exactly 4 characters\u0026#34; } ] } ] }, \u0026#34;webcredentials\u0026#34;: { \u0026#34;apps\u0026#34;: [ \u0026#34;ABCDE12345.com.example.app\u0026#34; ] } } 주의 사항 파일 이름은 json 확장자가 없는 apple-app-site-association이어야 합니다. 파일 위치는 http://foobar.com/.well-known/apple-app-site-association입니다. Apple JSON Metadata file Signing apple-app-site-association 파일은 Signing을 해서 저장해야 합니다. 여기서는 OpenSSL을 기준으로 기술합니다.\n1 openssl smime -sign -nodetach -in \u0026#34;./apple-app-site-association.json\u0026#34; -out \u0026#34;apple-app-site-association\u0026#34; -outform DER -inkey hostname.domain.key -signer hostname.domain.crt 만약 key, crt 확장자 파일 대신 pem 확장자 파일만 있다면 OpenSSL을 통해 생성 할 수 있습니다.\n1 2 openssl rsa -in key.pem -text \u0026gt; hostname.domain.key openssl x509 -inform PEM -in cert.pem -out hostname.domain.crt 웹서버에 올리는 파일은 텍스트 json 파일이 아닌 signing 한 json 확장자 없는 파일을 올려야 합니다.\n웹서버 설정 apple-app-site-association 파일에 대해 Content-type을 변경해야 합니다. 여기서는 Nginx를 기준으로 기술합니다.\n1 2 3 4 5 6 7 location ~ /.well-known/apple-app-site-association { default_type application/json; } location ~ /apple-app-site-association { default_type application/json; } 주의 사항 https를 통해 파일에 접근하도록 해야 합니다. https 인증서는 apple-app-site-association 파일을 signing 한 것과 같은 인증서를 써야 합니다. 유니버설 링크를 사용하는 사이트와 apple-app-site-association 파일은 서로 다른 도메인이어야 합니다. App ID Configuration Associated Domains Capabilities를 Enabled 해야 합니다. Xcode의 프로젝트 설정의 Signing \u0026amp; Capabilitites 탭의 Associated Domains에 다음 항목들을 추가합니다. 1 2 3 4 applinks:foobar.com applinks:ulink.foobar.com applinks:www.foobar.com webcredentials:ulink.foobar.com 위 예시는 도메인이 foobar.com이며, Apple JSON Metadata File 파일을 ulink.foobar.com에서 제공하는 경우입니다.\nAppDelegate 구현 iOS 9.1 이후 1 2 3 4 5 6 7 8 - (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray *))restorationHandler { NSURL *url = userActivity.webpageURL; // ... } - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary\u0026lt;UIApplicationOpenURLOptionsKey, id\u0026gt; *)options { // ... } iOS 13 이후 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func scene(_ scene: UIScene, continue userActivity: NSUserActivity) { guard userActivity.activityType == NSUserActivityTypeBrowsingWeb, let urlToOpen = userActivity.webpageURL else { return } // ... } func scene(_ scene: UIScene, openURLContexts URLContexts: Set\u0026lt;UIOpenURLContext\u0026gt;) { for urlContext in URLContexts { let urlToOpen = urlContext.url // ... } } 참고 Apple JSON Metadata File은 앱 설치 후 첫 실행 시 읽습니다. 그 이후로는 캐시를 활용하므로 개발 중 변경 시 Safari의 캐시를 삭제하고 앱 또한 삭제 후 재설치 하는 과정이 필요합니다. ","permalink":"https://sangheonhan.github.io/%EC%9C%A0%EB%8B%88%EB%B2%84%EC%84%A4-%EB%A7%81%ED%81%AC-universal-links/","summary":"유니버설 링크(Universal Links) 앱에서 유니버설 링크를 지원하기 위해서는 apple-app-site-association(AASA) 파일을 작성해서 웹 서버에 올려두는 작업이 필요합니다. Apple JSON Metadata file iOS 12 이전 1 2","title":"유니버설 링크 (Universal Links)"},{"content":"Editor Vim 오랜 시간 함께 했고 지금도 함께 하고 있는 에디터입니다. 처음에는 vi였고, 어느샌가 Vim으로 자연스럽게 바꾸었습니다. Sublime, Atom, Coda, NotePad++, EditPlus, UltraEdit를 써보기도 했지만 결국 Vim으로 돌아왔습니다.\n현재는 Vundle 플러그인 매니저를 사용해 여러 플러그인과 함께 사용하고 있습니다.\nSolarized - 솔라라이즈드 다크 테마 Syntastic - 문법 검사 The-NERD-tree - 트리 탐색기 ctrlp.vim - 퍼지 파인더 neocomplcache - 자동 완성 taglist.vim - 소스 코드 브라우저 vim-airline/vim-airline - 탭바/상태바 vim-airline/vim-airline-themes - vim-airline 테마 Vim은 터미널을 통해 주로 사용하지만, VS Code, DataGrip, Xcode를 쓸 때도 플러그인을 통해 사용하기도 합니다.\nWindows 10과 MacOS에서는 각각 gVim, MacVim을 쓰기도 합니다.\nVS Code 터미널에서 작업하는 것이 익숙하다 보니 Visual C++ 외에는 IDE를 거의 쓰지 않았습니다. 중간에 Eclipse와 PhpStorm을 잠시 쓰기도 했지만 결국 Vim으로 다시 돌아왔습니다.\n트위터를 통해 VS Code 알게되어 써보고 난 뒤에 매우 만족스러웠습니다. 그 이후 원격 작업이나 Docker 지원 등이 더 좋아지면서 현재는 Vim만큼 자주 쓰고 있습니다.\nTerminal Emulator 터미널은 항시 고민을 하게 만드는 도구였습니다. 지금도 그렇습니다. 예전에는 xterm, hanterm을 썼고, 그 뒤로 다양한 터미널 에뮬레이터를 써왔습니다.\n한동안 Linux에서는 GNOME Terminal, Windows에서는 iPutty, MacOS에서는 iTerm을 써오다, 최근 Windows 10에서는 Windows Terminal을 MacOS에서는 iTerm2를 쓰고 있습니다.\n평소 쓰는 OS가 여러 종류이다 보니 터미널 에뮬레이터를 통일시키기 위해 Hyper, kitty, Alacritty 등도 시도를 해보았지만, 폰트/테마 지원 등의 이유로 아직까지 각 OS 마다 서로 다른 터미널 에뮬레이터를 쓰고 있습니다.\niOS, iPadOS에서는 Terminus 무료 버전을 사용 중입니다.\nToolbox 개발 과정에서 유용하게 쓰고 있는 작은 도구가 몇개 있습니다.\nAck ack는 소스 코드 검색에 특화된 grep입니다. grep을 쓸 때 보다 빠르고 정확하게 찾을 수 있어 매우 유용하게 사용 중입니다.\nGrip grip은 GitHub Flavored Markdown 형식의 마크다운(Markdown) 문서의 프리뷰(Preview)를 웹브라우저로 확인 해 볼 수 있게 해주는 도구입니다. 마크다운 문서를 에디터로 열어 바로 볼 수도 있지만, 비개발자가 보기에는 조금 난해해 보일 수도 있고 렌더링을 하는 것이 좀 더 예쁘기 때문에 grip으로 렌더링한 후 웹브라우저의 결과물을 저장하여 전달하고 있습니다.\nApiDoc apidoc은 RESTful API 사용법을 정리하여 사내 공유하기 위해 사용 중입니다. 다른 좋은 도구들도 많지만 다소 방대한 느낌이어서 작고 가벼우면서도 소스 코드 안에 주석으로 적는 apidoc을 선택하였습니다.\nfzf fzf는 CLI를 사용 할 때 유용한 파인더(finder)입니다. 기본적인 사용 방법만으로도 유용하게 사용 중입니다.\nFonts DOS와 Windows 95 시절에는 샘물체라는 폰트를 썼습니다. 그뒤로 한동안 Fixedsys와 Courier New를 섞어쓰다, 본격적으로 개발 환경을 리눅스로 옮기면서 Ubuntu Mono, Bitstream Vera Sans Mono를 사용 했습니다.\n그 뒤로 Bitstream Vera Sans Mono Font와 맑은고딕을 합친 폰트를 꽤 오래 써왔지만 임의로 두 폰트를 합쳐서 만들었기에 Powerline fonts와 함께 사용하는데 어려움이 있어, 현재는 DejaVu Sans Mono for Powerline를 주로 쓰면서 보조적으로 Noto Sans Mono CJK KR을 사용 중입니다.\n근래 터미널 에뮬레이터의 경우 Unicode에 없는 글자를 만나면 별도의 글꼴에서 해당 글자를 찾는 기능을 지원하는 경우가 많아서 Noto Sans 폰트를 통해 글자가 안 나오는 문제를 방지 할 수 있습니다.\nShell 상당 기간 동안 bash를 썼지만 MacOS 기본 셸이 zsh로 바뀌면서 Windows(WSL)과 Ubuntu에서도 zsh을 기본셸로 사용 중입니다.\nbash를 사용했을 때는 다수의 설정 파일들을 로그인 때 읽어들이도록 했고, 이를 관리하는 것이 다소 번거로웠습니다. zsh를 쓰면서 Oh My Zsh를 통해 .zshrc 파일 하나에 설정을 통합하여 관리하고 있습니다.\nOh My Zsh 테마는 기본값인 agnoster를 사용 중입니다. 다른 멋진 테마들도 많았지만 agnoster로도 충분하다 느꼈기 때문입니다.\nTheme 예전에는 에디터나 IDE가 기본 제공하는 테마 중 하나를 선택하여 사용했지만 도구가 늘어나면서 통일감을 얻기 위해 Solarized Dark를 사용 중입니다.\nSolarized Dark는 에디터, 터미널 에뮬레이터, IDE 등에서 공식적으로 지원하는 경우가 많기도 하고, 비공식적인 패치도 많이 나와있어 테마 적용에 큰 어려움이 없습니다.\n","permalink":"https://sangheonhan.github.io/%EA%B0%9C%EB%B0%9C-%EB%8F%84%EA%B5%AC-%EB%B0%8F-%ED%99%98%EA%B2%BD-%EC%86%8C%EA%B0%9C/","summary":"Editor Vim 오랜 시간 함께 했고 지금도 함께 하고 있는 에디터입니다. 처음에는 vi였고, 어느샌가 Vim으로 자연스럽게 바꾸었습니다. Sublime, Atom, Coda, NotePad++, EditPlus, UltraEdit","title":"개발 도구 및 환경 소개"},{"content":"Name 한상헌 (Sangheon Han) a.k.a Bookworm Job Back-end Web Developer Skills Modern PHP, Linux, MySQL Interests Go, Python, Rust, TypeScript, LUA, Perl, C/C++ DevOps, Kubernetes, Docker, Vagrant Redis, ElasticSearch Agile, Scrum Groups Modern PHP User Group Founder Null@Root Past Member Links GitHub Twitter ","permalink":"https://sangheonhan.github.io/about/","summary":"Name 한상헌 (Sangheon Han) a.k.a Bookworm Job Back-end Web Developer Skills Modern PHP, Linux, MySQL Interests Go, Python, Rust, TypeScript, LUA, Perl, C/C++ DevOps, Kubernetes, Docker, Vagrant Redis, ElasticSearch Agile, Scrum Groups Modern PHP User Group Founder Null@Root Past Member Links GitHub Twitter","title":"About"},{"content":"배경 여러 버전의 OS에서 돌아가는 여러 언어로 만든 시스템을 개발하려다 보니 개발 환경을 구축하는 것도 쉬운 일이 아닙니다. Vagrant도 사용을 해봤지만, 그렇게 획기적으로 편리하다는 인상은 못 받았습니다. 개발 환경을 배포하는 측면에서 좋았지만, 소규모 개발팀에서 배포를 위해 이미지를 빌드하는 과정이 오버헤드처럼 느껴졌습니다.\n그러던 차에 Docker를 이용해서 개발 환경을 구축하는 것이 편리하다는 것을 느끼고, 본격적으로 Docker를 통해서 개발 환경을 구축 해보았습니다.\n제약 사항 개발 환경 구축에 있어 아래의 제약 사항을 설정하고 접근했습니다.\n환경(Development, QA, Stage, Production)에 따른 설정 변경 등의 수작업을 최소화 합니다. 최대한 Docker 기본의 기능을 활용하여 동작합니다. Local/Remote, Vim+Tmux/VS Code 조합에서 동일한 코드 트리로 설정 변경 없이 작업 가능하도록 합니다. 모범사례(Best Practice)를 찾아내서 최대한 그에 맞춰 구성하도록 합니다. Dockerfile \u0026amp; Docker Compose 개발 환경을 구축하면서 Dockerfile과 Docker Compose의 관계에 대한 감을 잡는 것이 어려웠습니다. 왜냐하면 특정 작업을 양쪽 어디에 넣어도 동작하기 때문입니다. 여러 문서와 StackOverflow의 답변을 참고로 해서 다음과 같은 기준을 만들어 낼 수 있었습니다.\n가능하면 최대한 넣을 수 있는 설정/작업(RUN)은 Dockerfile에 넣습니다. Dockerfile은 1 개만 사용합니다. 환경에 따라 동작하는 여러 개의 Dockerfile을 두지 않습니다. 즉, 이 말을 바꿔 말하면 환경에 따라 다르게 동작해야 하는 설정/작업은 Dockerfile에 넣으면 안 됩니다. 나머지 설정/작업은 Docker Compose에 맡깁니다. 환경에 따라 변화하는 설정/작업은 Docker Compose에서 처리하도록 합니다. 자세한 내용은 docker-compose.yml 설명 할 때 다루겠습니다. Dockerfile Docker 기본 기능 및 설정에 대한 설명은 생략하고, 이슈와 해결방법에 초점을 두어 설명하도록 하겠습니다.\nMulti-stage builds Go와 같은 언어는 컴파일 과정이 필수적이지만, 실행을 할 때 Go의 빌드 환경이 필요하지는 않습니다. 실행 환경이 빌드 환경을 포함한다면 쓸데없이 컨테이너 크기만 커집니다. 이런 문제를 해결하기 위해 Mult-stage builds를 사용했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ARG GOLANG_DOCKER_IMAGE=debian:stretch-slim FROM golang:1.12-stretch AS builder COPY . /go/src/github.com/sangheonhan/foobar/ WORKDIR /go/src/github.com/sangheonhan/foobar/ RUN go get \u0026#34;github.com/gorilla/mux\u0026#34; \u0026amp;\u0026amp; go build -o foobar main.go FROM ${GOLANG_DOCKER_IMAGE} COPY --from=builder /go/src/github.com/sangheonhan/foobar/ /go/src/github.com/sangheonhan/foobar/ WORKDIR /go/src/github.com/sangheonhan/foobar/ EXPOSE 80 CMD [\u0026#34;./foobar\u0026#34;] GOLANG_DOCKER_IMAGE 환경변수를 사용한 이유는 Production 환경에서는 Go 빌드 환경이 필요없기 때문에 debian 이미지를 사용하고, 개발 환경에서는 Docker Compose를 통해 이미지를 사용하도록 지정하여 실행시에도 Go 빌드 환경을 통한 디버깅이 용이하도록 했습니다.\nSSH Key 컨테이너 내부에서 외부로 SSH 연결이 필요 했습니다. 이를 위해서 Docker Screts 사용하는 것을 권하지만, 아직 Docker Swarm을 사용하지 않기 때문에, 기존처럼 SSH Key를 빌드 과정에서 컨테이너에 포함 시키는 방법을 사용하기로 했습니다.\n다만 SSH Key를 Docker 설정에 포함 시키지 않고, 빌드 과정에서 시스템의 것을 가져오도록 만들었습니다. 이 때 한가지 문제가 있는데 외부의 SSH Key 문자열을 Docker에서 제대로 처리하지 못 한다는 점입니다. 이를 회피하기 위해서 Base64 인코딩을 하여 인자로 넣은 후, 다시 빌드 과정에서 디코딩을 하도록 했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FROM python:3.7.4-slim-stretch ARG ssh_private_key_base64 ARG ssh_public_key_base64 COPY . /usr/src/foobar/ WORKDIR /usr/src/foobar/ RUN pip install --no-cache-dir -r requirements.txt \u0026amp;\u0026amp; mkdir -p /root/.ssh \u0026amp;\u0026amp; chmod 0700 /root/.ssh \u0026amp;\u0026amp; echo $ssh_private_key_base64 | base64 -d \u0026gt; /root/.ssh/id_rsa \u0026amp;\u0026amp; echo $ssh_public_key_base64 | base64 -d \u0026gt; /root/.ssh/id_rsa.pub \u0026amp;\u0026amp; chmod 600 /root/.ssh/id_rsa /root/.ssh/id_rsa.pub \u0026amp;\u0026amp; echo \u0026#34;Host 192.168.0.* foobar*\\ntStrictHostKeyChecking no\\nUser root\\nPort 22\\n\u0026#34; \u0026gt;\u0026gt; /root/.ssh/config CMD [ \u0026#34;python\u0026#34;, \u0026#34;./foobar.py\u0026#34; ] 1 2 3 4 5 6 7 8 version: \u0026#34;3.3\u0026#34; services: foobar: build: context: . args: ssh_private_key_base64: \u0026#34;${SSH_PRIVATE_KEY_BASE64:?Missing environment value - SSH private key}\u0026#34; ssh_public_key_base64: \u0026#34;${SSH_PUBLIC_KEY_BASE64:?Missing environment value - SSH public key}\u0026#34; SSH_PRIVATE_KEY_BASE64, SSH_PUBLIC_KEY_BASE64 환경 변수는 .env 파일을 통해서 자동으로 읽어 들이도록 했고, .env 파일은 스크립트를 사용해서 미리 빌드 해둘 수 있게 만들었습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #! /bin/bash if [ \u0026#34;$1\u0026#34; == \u0026#34;help\u0026#34; ] || [ \u0026#34;$1\u0026#34; == \u0026#34;-h\u0026#34; ]; then echo \u0026#34;Usage: mkenv [private key file] [public key file]\u0026#34; exit 1 fi if [ \u0026#34;$1\u0026#34; != \u0026#34;\u0026#34; ]; then SSH_PRIVATE_KEY_FILE=$1 else SSH_PRIVATE_KEY_FILE=~/.ssh/id_rsa fi if [ \u0026#34;$2\u0026#34; != \u0026#34;\u0026#34; ]; then SSH_PUBLIC_KEY_FILE=$1 else SSH_PUBLIC_KEY_FILE=~/.ssh/id_rsa.pub fi if [ ! -f $SSH_PRIVATE_KEY_FILE ]; then echo $SSH_PRIVATE_KEY_FILE is not found. exit 1 fi if [ ! -f $SSH_PUBLIC_KEY_FILE ]; then echo $SSH_PUBLIC_KEY_FILE is not found. exit 1 fi echo Private key = $SSH_PRIVATE_KEY_FILE echo Public key = $SSH_PUBLIC_KEY_FILE SSH_PRIVATE_KEY_BASE64=`cat ${SSH_PRIVATE_KEY_FILE} | base64 | paste -s -d \u0026#39;\u0026#39;` SSH_PUBLIC_KEY_BASE64=`cat ${SSH_PUBLIC_KEY_FILE} | base64 | paste -s -d \u0026#39;\u0026#39;` echo SSH_PRIVATE_KEY_BASE64=${SSH_PRIVATE_KEY_BASE64} \u0026gt; .env echo SSH_PUBLIC_KEY_BASE64=${SSH_PUBLIC_KEY_BASE64} \u0026gt;\u0026gt; .env echo Done. 위 스크립트를 통해서 Base64로 인코딩 한 값을 .env 파일에 생성 할 수 있습니다. .env는 Docker Compose에서 자동으로 읽어서 적용하므로 docker-compose.yml과 Dockefile에서 해당 값을 사용 할 수 있습니다.\nUbuntu Repository Docker가 아닌 환경에서도 간혹 격는 문제인데 Md5sum 값이 다르다면서 패키지 저장소를 업데이트 하는 과정에 오류가 발생하는 경우가 있습니다. 이번 개발 환경 구축 시에도 동일한 문제를 겪었고, Dockerfile에 저장소 주소를 초기화 하는 방법으로 해당 문제를 해결했습니다.\n1 2 3 4 5 6 RUN rm -rf /etc/apt/sources.list \u0026amp;\u0026amp; (echo \u0026#34;deb mirror://mirrors.ubuntu.com/mirrors.txt bionic main restricted universe multiverse\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;deb mirror://mirrors.ubuntu.com/mirrors.txt bionic-updates main restricted universe multiverse\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;deb-src mirror://mirrors.ubuntu.com/mirrors.txt bionic-updates main restricted universe multiverse\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;deb mirror://mirrors.ubuntu.com/mirrors.txt bionic-backports main restricted universe multiverse\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;deb mirror://mirrors.ubuntu.com/mirrors.txt bionic-security main restricted universe multiverse\u0026#34;) \u0026gt; /etc/apt/sources.list \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* \u0026amp;\u0026amp; apt clean \u0026amp;\u0026amp; apt-get update \u0026amp;\u0026amp; apt-get install -y libsm6 libxext6 libxrender-dev 컨테이너 이미지 안의 패키지 저장소 주소를 초기화 시키고, 우분투 서버의 미러 사이트 주소를 가져와서 동작하도록 합니다. 이렇게 처리를 하면 지역이 바뀌거나 미러 사이트 주소에 변화가 생겨도 대응이 되기 때문에 소스 코드 트리에 넣기에 부담이 줄어듭니다.\ndocker-compose.yml 환경 별 설정 위에서 언급했듯이 환경에 따른 빌드의 변화를 Dockerfile이 아닌 Docker Compose, 즉 docker-compose.yml을 통해서 처리하도록 했습니다.\n환경에 따라 달라지는 변화에 대응하는 방법을 크게 두 가지로 나뉩니다.\ndocker-compose.yml과 환경 별로 나눈 docker-compose.{environment}.yml들을 이용하는 방법 docker-compose.yml과 docker-compose.override.yml 심볼릭 링크를 이용하는 방법 첫번째 방법은 docker-compose.yml에 공통적인 설정을 넣고, 환경에 따라 docker-compose.development.yml, docker-compose.qa.yml, docker-compose.stage.yml, docker-compose.production.yml을 만들어서 실행 시 명령행 인자를 통해서 적절한 파일을 사용하는 방법입니다.\n1 2 # 개발 환경 $ docker-compose -f docker-compose.yml -f docker-compose.development.yml 1 2 # 운영 환경 $ docker-compose -f docker-compose.yml -f docker-compose.production.yml 두번째 방법은 첫번째와 동일하게 환경에 따라 파일은 나누되 명령행 인자로 지정하는 것이 아니라 docker-compose.override.yml 파일로 심볼릭 링크를 하는 방법입니다.\n1 2 # 개발 환경 $ ln -s docker-compose.development.yml docker-compose.override.yml 1 2 # 운영 환경 $ ln -s docker-compose.production.yml docker-compose.override.yml Docker Compose를 docker-compose.yml을 읽은 후 docker-compose.override.yml을 추가적으로 읽습니다.\n여기서 환경 별로 구축을 할 때 주의해야 할 점이 있습니다. docker-compose.yml에서 한 설정을 덮어 쓰거나 새로운 설정을 추가하는 것은 가능하지만, 지우는 기능은 없으므로, 만약 특정 환경에서는 필요하지 않는 어떤 설정이 있다면 절대로 docker-compose.yml에 넣으면 안 됩니다. 번거롭더라도 해당 환경을 특정 환경을 제외한 나머지 환경을 위한 설정 파일에 모두 해당 내용을 추가해야 합니다.\n아울러 환경 별로 필요한 어떤 환경 설정이 있다면 .env가 아닌 Docker Compose 설정에서 env_file 기능을 사용하여 분리하여 지정 할 수 있습니다.\ndevcontainer.yml 지금까지 설정으로 Vim을 이용한 작업에는 문제가 없습니다. 여기에 VS Code를 이용한 작업도 가능하도록 설정을 더 추가했습니다.\nDockerfile이 있는 프로젝트 루트에 .devcontainer 디렉토리를 생성하고, 그 안에 devcontainer.json과 docker-compose.extend.yml 파일을 생성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { // See https://aka.ms/vscode-remote/devcontainer.json for format details. \u0026#34;name\u0026#34;: \u0026#34;Foobar\u0026#34;, // Update the \u0026#39;dockerComposeFile\u0026#39; list if you have more compose files or use different names. // The .devcontainer/docker-compose.yml file contains any overrides you need/want to make. \u0026#34;dockerComposeFile\u0026#34;: [ \u0026#34;../../docker-compose.yml\u0026#34;, \u0026#34;../../docker-compose.override.yml\u0026#34;, \u0026#34;./docker-compose.extend.yml\u0026#34; ], // The \u0026#39;service\u0026#39; property is the name of the service for the container that VS Code should // use. Update this value and .devcontainer/docker-compose.yml to the real service name. \u0026#34;service\u0026#34;: \u0026#34;foobar\u0026#34;, // The optional \u0026#39;workspaceFolder\u0026#39; property is the path VS Code should open by default when // connected. This is typically a file mount in .devcontainer/docker-compose.yml \u0026#34;workspaceFolder\u0026#34;: \u0026#34;/usr/src/foobar/\u0026#34;, // Uncomment the next line if you want to keep your containers running after VS Code shuts down. // \u0026#34;shutdownAction\u0026#34;: \u0026#34;none\u0026#34;, // Uncomment the next line if you want to add in default container specific settings.json values // \u0026#34;settings\u0026#34;: { \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Quiet Light\u0026#34; }, // Uncomment the next line to run commands after the container is created - for example installing git. \u0026#34;postCreateCommand\u0026#34;: \u0026#34;apt-get update \u0026amp;\u0026amp; apt-get install -y git \u0026amp;\u0026amp; pip install pylint black rope\u0026#34;, // Add the IDs of any extensions you want installed in the array below. \u0026#34;extensions\u0026#34;: [\u0026#34;ms-python.python\u0026#34;] } dockerComposeFile 설정에서 나온 순서대로 설정 파일을 읽습니다. service 설정은 꼭 docker-compose.yml와 이름이 같도록 해야 합니다.\nVS Code를 이용 할 때 IDE 기능이 로컬 머신이 아닌 컨테이너 내부에서 동작하므로, 개발에 필요한 도구들도 설치하도록 해야 합니다.\n1 \u0026#34;postCreateCommand\u0026#34;: \u0026#34;apt-get update \u0026amp;\u0026amp; apt-get install -y git \u0026amp;\u0026amp; pip install pylint black rope\u0026#34; 아울러 VS Code의 확장 또한 컨테이너 내부에서 실행하므로, 이미 로컬 머신에 해당 확장을 설치했다고 하여도 컨테이너에 설치하도록 하는 설정을 추가해줘야 합니다.\n1 \u0026#34;extensions\u0026#34;: [\u0026#34;ms-python.python\u0026#34;] docker-compose.extend.yml에는 VS Code로 개발 할 때만 필요한 Docker Compose 설정을 적습니다.\n1 2 3 4 5 6 7 8 version: \u0026#34;3.3\u0026#34; services: foobar: cap_add: - SYS_PTRACE security_opt: - seccomp:unconfined command: sleep infinity cap_add와 security_opt 설정은 디버깅을 위한 권한을 부여하기 위한 것입니다. command는 컨테이너 실행(run) 시 프로그램을 실행하지 않도록 하여, 개발자가 원할 때 실행 할 수 있도록 하기 위한 설정입니다.\n설정 후 해당 프로젝트 폴더를 Remote-Containers: Open Folder in Container로 열면 됩니다. 만약 Dockerfile이 있는 프로젝트 루트를 그냥 폴더 열기로 열면 우측 하단에 컨테이너로 열지 물어보는데, Reopen in Container 버튼을 눌러 컨테이너로 여는 것도 가능합니다.\n마무리 개발 환경을 Docker로 구축하는 방법에 대해 이야기를 해보았습니다. 이미 Docker를 어느 정도 사용 할 줄 아는 분들을 기준으로 했기 때문에 처음 Docker를 쓰는 분들은 잘 와닿지 않으실 수도 있을 것 같습니다.\n하지만 개발 환경을 Docker로 구축을 하시다 보면 여기서 이야기한 문제를 경험하고 해결 방법을 고민하게 될 때를 분명히 경험하리라 생각합니다. 그 때 이 글이 조금이라도 도움 됐으면 합니다.\n","permalink":"https://sangheonhan.github.io/docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/","summary":"배경 여러 버전의 OS에서 돌아가는 여러 언어로 만든 시스템을 개발하려다 보니 개발 환경을 구축하는 것도 쉬운 일이 아닙니다. Vagrant도 사용을 해봤지만, 그","title":"Docker를 이용한 개발 환경 구축하기"},{"content":"원격 호스트에 명령을 실행하기 위해서는 우선 SSH 키를 통한 연결이 필요합니다. SSH 키를 연결하는 방법은 오픈튜토리얼스의 강좌 참고하시면 됩니다.\n우선 SSH 라이브러리를 좀 더 편리하기 쓰기 위해 랩퍼를 하나 설치합니다. 이 라이브러리를 사용하기 위해서는 PHP에 ssh2 익스텐션이 설치되어 있어야 합니다.\n1 composer require herzult/php-ssh 다음은 원격 호스트에 ls -al 명령을 실행하는 짧은 예제입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php namespace Example; require \u0026#39;vendor/autoload.php\u0026#39;; $configuration = new \\Ssh\\Configuration(\u0026#39;remote.hostname\u0026#39;); $authentication = new \\Ssh\\Authentication\\PublicKeyFile( \u0026#39;sangheon\u0026#39;, \u0026#39;/home/sangheon/.ssh/id_rsa.pub\u0026#39;, \u0026#39;/home/sangheon/.ssh/id_rsa\u0026#39; ); $session = new \\Ssh\\Session($configuration, $authentication); $exec = $session-\u0026gt;getExec(); echo $exec-\u0026gt;run(\u0026#39;ls -al\u0026#39;); 위 예제 외에 패스워드를 통한 인증도 가능합니다. 자세한 것은 herzult/php-ssh 라이브러리 문서를 참고하시면 됩니다.\n","permalink":"https://sangheonhan.github.io/php%EB%A1%9C-%EC%9B%90%EA%B2%A9-%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%97%90-cli-%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%8B%A4%ED%96%89%EB%B2%95/","summary":"원격 호스트에 명령을 실행하기 위해서는 우선 SSH 키를 통한 연결이 필요합니다. SSH 키를 연결하는 방법은 오픈튜토리얼스의 강좌 참고하시면 됩니다. 우선 SSH 라이브러리","title":"PHP로 원격 호스트에 CLI 커맨드 실행법"},{"content":"PHP를 사용하면서 배열(Array)를 사용하지 않는 경우란 매우 드물겁니다. 배열(Array)와 사전(Dictionary)로 구별하는 Perl이나 Python과 달리 둘이 합쳐진 모양새를 가진 PHP 배열(이하 Array)은 PHP로 프로그래밍을 할 때 감초처럼 빠지지 않는 자료 구조일겁니다.\n하지만, Array가 언제나 최적의 도구는 아닙니다. 경우에 따라 다른 도구를 사용하는 것이 좀 더 나은 결과를 만들어 낼 수도 있습니다. 이 글에서는 Array와 비슷하지만 조금은 다른 또 다른 배열 형태의 자료 구조 두가지를 소개하려고 합니다.\nSplFixedArray SPL(Stardard PHP Library)에는 다양한 자료 구조를 처리하는 클래스가 포함되어 있습니다. 그 중 하나가 SplFixedArray입니다. 이름에서 알 수 있듯 크기를 정하지 않고 사용하는 Array와 달리 인스턴스 생성시 고정된 크기를 정하는 클래스입니다.\n인스턴스를 생성해야 한다는 것을 제외하면 기본적인 사용법은 Array와 동일합니다.\n1 2 3 4 5 \u0026lt;?php $sfa = new SplFixedArray(100); for ($i = 0; $i \u0026lt; 100; $i++) { $sfa[$i] = $i; } SplFixedArray과 Array의 가장 큰 차이점은 생성시 지정한 크기를 벗어나는 경우 RuntimeException을 던진다는 것입니다. 만약 배열의 크기가 고정적이거나, 가변적으로 바뀌는 상황이 아니라면 SplFixedArray를 사용하는 것이 속도면에서 잇점이 있습니다. PHP 5.6 기준으로 읽기는 다소 빠른 수준이나 쓰기는 약 1.5 ~ 2배의 속도 차이가 있습니다.\n만약 SplFixedArray의 크기를 바꿔야 할 필요가 생긴다면 SplFixedArray::setSize 함수를 통해서 크기를 변경 할 수 있습니다. 다만, 현재 크기 보다 작은 크기로 바꾸는 경우 뒤 쪽 데이터가 잘려나가면, 큰 경우는 null이 뒤에 따라붙게 됩니다.\nJudy Array PHP의 또 다른 배열 한가지는 Judy입니다. SPL와 같은 기본 모듈은 아니지만 PECL을 통해 손쉽게 로드 할 수 있습니다. 한가지 아쉬운 점은 현재 1.0.2 버전 기준으로 PHP 5.6까지만 지원한다는 점입니다.\nJudy는 Sparse Array에 특화된 배열입니다. 즉, 첨자가 연속적이지 않고 매우 드물게 나타나는 배열을 처리하는데 강점을 가집니다. Array와 비교하면 약 4 ~ 12배 정도의 성능 차이를 보입니다. 만약 다루려는 데이터가 Sparse Array 형태라면 Judy를 사용하는 것이 성능면에서 상당한 잇점이 있습니다.\n1 2 3 4 5 \u0026lt;?php $judy = new Judy(Judy::INT_TO_INT); for ($i = 0; $i \u0026lt; 100; $i++) { $judy[$i * 1000000] = $i; } 마무리 보통의 경우 기본 Array로 충분하지만, 데이터의 갯수고 고정적이거나 첨자가 매우 드물게 떨어져있는 경우 SplFixedArray나 Judy를 사용해서 더 빠르게 처리 할 수 있습니다. 다만 SplFixedArray나 Judy의 경우 배열 관련 기본 내장 함수를 이용하는 것이 불가능하므로 이점을 미리 감안하여야 합니다.\n지금까지 PHP 기본 Array만 사용하셨다면 SplFixedArray나 Judy를 이용하여 좀 더 성능 좋은 PHP를 경험 해보시길 권합니다.\n","permalink":"https://sangheonhan.github.io/php-%EB%B0%B0%EC%97%B4-%EC%84%B8%EA%B0%80%EC%A7%80-array-splfixedarray-judy-array/","summary":"PHP를 사용하면서 배열(Array)를 사용하지 않는 경우란 매우 드물겁니다. 배열(Array)와 사전(Dictionary)로 구별하는 Perl이","title":"PHP 배열 세가지: Array, SplFixedArray, Judy Array"},{"content":" 1 2 3 4 5 6 7 # coding=utf-8 import re r = re.compile(r\u0026#39;[^\\sa-zA-Z0-9ㄱ-ㅣ가-힣]+\u0026#39;) s = \u0026#39;대법원장의 임기는 6년으로 하며, 중임할 수 없다. 법관은 탄핵 또는 금고 이상의 형의 선고에 의하지 아니하고는 파면되지 아니하며, 징계처분에 의하지 아니하고는 정직·감봉 기타 불리한 처분을 받지 아니한다.\u0026#39; print r.sub(\u0026#39;\u0026#39;, s) ","permalink":"https://sangheonhan.github.io/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90%EC%84%9C-%EA%B8%B0%ED%98%B8-%EC%97%86%EC%95%A0%EB%8A%94-%EB%B2%95/","summary":"1 2 3 4 5 6 7 # coding=utf-8 import re r = re.compile(r\u0026#39;[^\\sa-zA-Z0-9ㄱ-ㅣ가-힣]+\u0026#39;) s = \u0026#39;대법원장의 임","title":"파이썬 문자열에서 기호 없애는 법"},{"content":"설치 Console_CommandLine 패키지는 명령행 인자를 파싱하는 PEAR 라이브러리입니다. 컴포져를 이용해서 설치하려면 composer.json에 다음 내용을 알맞은 위치에 추가하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;pear\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://pear.php.net\u0026#34; } ], \u0026#34;require\u0026#34;: { \u0026#34;pear-pear.php.net/Console_CommandLine\u0026#34;: \u0026#34;*\u0026#34; } } 기본 사용법 Console_CommandLine을 사용하기 위해서는 Console_CommandLine 인스턴스를 생성한 후에, addOption() 또는 addArgument() 메소드로 옵션이나 인자에 대한 명세를 설정한 후 parse() 메소드를 통해 파싱을 하면 됩니다. 이 과정 중에 명세에 맞지 않는 인자를 발견하면 예외가 발생합니다. 이 때 발생한 예외를 잡아서 적절한 사용법 안내를 화면에 출력합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php require \u0026#39;vendor/autoload.php\u0026#39;; $parser = new Console_CommandLine([\u0026#39;name\u0026#39; =\u0026gt;\u0026#39;hello\u0026#39;]); $parser-\u0026gt;description = \u0026#39;Hello Program\u0026#39;; $parser-\u0026gt;version = \u0026#39;1.0.0\u0026#39;; try { $result = $parser-\u0026gt;parse(); echo \u0026#39;Hello.\u0026#39;.PHP_EOL; } catch (Exception $e) { $parser-\u0026gt;displayError($e-\u0026gt;getMessage()); } 우선 컴포져를 통해서 Console_CommandLine 패키지를 읽어들이기 위해 vendor/autoload.php를 불러들입니다. 그 다음 Console_CommandLine 인스턴스를 생성하면서 프로그램 이름을 \u0026ldquo;hello\u0026quot;로 설정합니다. 프로그램 설명은 \u0026ldquo;Hello Program\u0026quot;으로, 버전은 \u0026ldquo;1.0.0\u0026quot;으로 설정합니다. 설정은 인스턴스를 생성하면서 매개변수로 전달하여 할 수도 있고, 생성 후 프로퍼티에 값을 대입하여 할 수도 있습니다.\n1 2 3 4 5 6 7 8 9 php example01.php -h Hello Program Usage: hello [options] Options: -h, --help show this help message and exit -v, --version show the program version and exit 기본적으로 도움말(-h, \u0026ndash;help) 옵션을 제공합니다. 버전(-v, \u0026ndash;version) 옵션은 버전을 설정한 경우에만 사용 가능합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?php require \u0026#39;vendor/autoload.php\u0026#39;; $parser = new Console_CommandLine([\u0026#39;name\u0026#39; =\u0026gt;\u0026#39;hello\u0026#39;]); $parser-\u0026gt;description = \u0026#39;Hello Program\u0026#39;; $parser-\u0026gt;version = \u0026#39;1.0.0\u0026#39;; $parser-\u0026gt;addOption( \u0026#39;korean\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-k\u0026#39;, \u0026#39;long_name\u0026#39; =\u0026gt; \u0026#39;--korean\u0026#39;, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;한국어\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreTrue\u0026#39; ] ); try { $result = $parser-\u0026gt;parse(); if (isset($result-\u0026gt;options[\u0026#39;korean\u0026#39;]) \u0026amp;\u0026amp; $result-\u0026gt;options[\u0026#39;korean\u0026#39;] == true) { $hello = \u0026#39;안녕하세요.\u0026#39;; } else { $hello = \u0026#39;Hello.\u0026#39;; } echo $hello.PHP_EOL; } catch (Exception $e) { $parser-\u0026gt;displayError($e-\u0026gt;getMessage()); } 이번에는 인사를 한국어로 출력하는 옵션(-k, \u0026ndash;korean)을 추가했습니다. addOption() 메소드를 이용해 옵션 이름은 \u0026ldquo;korean\u0026quot;으로 하고, 짧은 옵션은 -k, 긴 옵션은 --korean으로 설정했습니다. description은 옵션에 대한 설명으로 도움말(-h) 옵션 사용시 출력됩니다. action은 옵션을 지정했을 때 어떻게 처리하는가에 대한 값으로, 여기서는 -k 옵션을 지정하면 true 값으로 설정하도록 했습니다. (StoreTrue)\n옵션값은 options 배열에 옵션 이름을 첨자로 사용해서 확인 할 수 있습니다. 옵션을 사용하지 않은 경우 null 값이 됩니다. 여기서는 StoreTrue 액션으로 지정했으므로, 한국어 옵션을 사용한 경우 true 값이 됩니다.\n1 2 3 4 5 6 7 8 9 10 php example-2.php -h Hello Program Usage: hello [options] Options: -k, --korean 한국어 -h, --help show this help message and exit -v, --version show the program version and exit 도움말을 출력 해보면 추가한 한국어 옵션을 확인 할 수 있습니다.\n1 php example-2.php 1 Hello. 1 php example-2.php -k 1 안녕하세요. 1 php example-2.php --korean 1 안녕하세요. 이제 한국어 옵션(-k, --korean)을 사용하면 한국어로 인사말을 출력합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?php require \u0026#39;vendor/autoload.php\u0026#39;; $parser = new Console_CommandLine([\u0026#39;name\u0026#39; =\u0026gt;\u0026#39;hello\u0026#39;]); $parser-\u0026gt;description = \u0026#39;Hello Program\u0026#39;; $parser-\u0026gt;version = \u0026#39;1.0.0\u0026#39;; $parser-\u0026gt;addOption( \u0026#39;korean\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-k\u0026#39;, \u0026#39;long_name\u0026#39; =\u0026gt; \u0026#39;--korean\u0026#39;, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;한국어\u0026#39;, \u0026#39;help_name\u0026#39; =\u0026gt; \u0026#39;KOREAN\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreTrue\u0026#39; ] ); $parser-\u0026gt;addArgument( \u0026#39;name\u0026#39;, [ \u0026#39;multiple\u0026#39; =\u0026gt; true, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;이름\u0026#39;, \u0026#39;help_name\u0026#39; =\u0026gt; \u0026#39;NAME\u0026#39; ] ); try { $result = $parser-\u0026gt;parse(); if (isset($result-\u0026gt;options[\u0026#39;korean\u0026#39;]) \u0026amp;\u0026amp; $result-\u0026gt;options[\u0026#39;korean\u0026#39;] == true) { $hello = \u0026#39;안녕하세요.\u0026#39;; } else { $hello = \u0026#39;Hello.\u0026#39;; } foreach ($result-\u0026gt;args[\u0026#39;name\u0026#39;] as $name) { echo \u0026#34;{$hello} {$name}.\u0026#34;.PHP_EOL; } } catch (Exception $e) { $parser-\u0026gt;displayError($e-\u0026gt;getMessage()); } 이름을 명령행 인자로 받아 인사를 하도록 해보았습니다. addArgument() 메소드를 통해 명령행 인자를 추가 할 수 있습니다. 명령행 인자 이름은 \u0026ldquo;name\u0026quot;으로, description은 \u0026ldquo;이름\u0026quot;으로, help_name은 \u0026ldquo;NAME\u0026quot;으로 설정했습니다. description과 help_name은 도움말 화면을 통해 출력됩니다.\nmultiple을 true로 설정하면, 인자를 여럿 받을 수 있습니다. 도움말에는 help_name 뒤에 숫자를 붙이고 말줄임표를 뒤에 덧붙여서 인자를 여럿 사용 할 수 있다는 것을 보여줍니다.\n명령행 인자는 args 배열을 통해서 읽어들일 수 있습니다. 옵션과 마찬가지로 명령행 인자 이름 \u0026ldquo;name\u0026quot;이 첨자로 사용됩니다.\n1 php example-3.php -h 1 2 3 4 5 6 7 8 9 10 11 12 Hello Program Usage: hello [options] NAME1 NAME2 ... Options: -k, --korean 한국어 -h, --help show this help message and exit -v, --version show the program version and exit Arguments: NAME 이름 옵션 다음에 \u0026ldquo;NAME\u0026quot;인자를 쓸 수 있다고 도움말에 표시됩니다. 인자가 어떤 값인지에 대한 설명은 하단 \u0026ldquo;Arguments\u0026quot;부분에 출력됩니다.\n1 php example-3.php bookworm 1 Hello. bookworm. 1 php example-3.php -k bookworm hellfire 1 2 안녕하세요. bookworm. 안녕하세요. hellfire. XML 명령행 인자들에 대한 설정을 PHP 코드가 아닌 XML 파일을 이용해 할 수도 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;command\u0026gt; \u0026lt;name\u0026gt;hello\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Hello Program\u0026lt;/description\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;option name=\u0026#34;korean\u0026#34;\u0026gt; \u0026lt;short_name\u0026gt;-k\u0026lt;/short_name\u0026gt; \u0026lt;long_name\u0026gt;--korean\u0026lt;/long_name\u0026gt; \u0026lt;description\u0026gt;한국어\u0026lt;/description\u0026gt; \u0026lt;help_name\u0026gt;KOREAN\u0026lt;/help_name\u0026gt; \u0026lt;action\u0026gt;StoreTrue\u0026lt;/action\u0026gt; \u0026lt;/option\u0026gt; \u0026lt;argument name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;description\u0026gt;이름\u0026lt;/description\u0026gt; \u0026lt;multiple\u0026gt;true\u0026lt;/multiple\u0026gt; \u0026lt;help_name\u0026gt;NAME\u0026lt;/help_name\u0026gt; \u0026lt;/argument\u0026gt; \u0026lt;/command\u0026gt; fromXmlFile 메소드는 지정한 XML 파일을 읽어들이고 Console_CommandLine 인스턴스를 반환합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php require \u0026#39;vendor/autoload.php\u0026#39;; $parser = Console_CommandLine::fromXmlFile(\u0026#39;hello.xml\u0026#39;); try { $result = $parser-\u0026gt;parse(); // ...생략... } catch (Exception $e) { $parser-\u0026gt;displayError($e-\u0026gt;getMessage()); } 다음 글에서는 옵션(Option)에 대해 더 자세히 다뤄보려고 합니다.\n옵션 Console_CommandLine 패키지는 유용한 옵션들을 제공합니다. 이런 옵션들을 적절히 사용하면 깔끔하면서도 강력한 명령행 인자를 사용자에게 제공 할 수 있습니다.\nChoices 1 2 3 4 5 6 7 8 9 $parser-\u0026gt;addOption( \u0026#39;color\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-c\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreString\u0026#39;, \u0026#39;choices\u0026#39; =\u0026gt; [\u0026#39;black\u0026#39;, \u0026#39;white\u0026#39;], \u0026#39;add_list_option\u0026#39; =\u0026gt; true, ] ); Choices는 정해진 값 중 하나만을 인자로 받도록 하는 옵션입니다. 예제처럼 색상을 흰색(white)과 검정색(black)만 받고 싶다면, choices에 받고자 하는 인자들을 배열로 정의하면 됩니다.\nadd_list_option은 기본값이 false지만, true로 설정하면 앞에 --list가 붙은 --list-color 옵션이 자동으로 추가됩니다. 이 옵션을 통해 사용자는 어떤 값들이 선택지로 제공되는지 확인 할 수 있습니다.\nCounter 1 2 3 4 5 6 7 $parser-\u0026gt;addOption( \u0026#39;verbose\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-v\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;Counter\u0026#39;, ] ); Counter 옵션은 사용자가 여러번 중복으로 옵션을 사용했을 경우 사용한 횟수를 값으로 저장합니다. 예를 들어 -v -v -v와 같이 3번 사용했을 경우 verbose의 값은 3이 됩니다.\nPassword 1 2 3 4 5 6 7 $parser-\u0026gt;addOption( \u0026#39;password\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-p\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;Password\u0026#39;, ] ); Password 옵션은 사용자가 값을 생략했을 경우 프롬프트를 띄우고 직접 입력을 받도록 요청합니다. 이 때 사용자 입력은 화면에 출력되지 않습니다.\nCallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function getByteSize($value, $option, $result, $parser, $params = []) { static $sizeTable = [\u0026#39;K\u0026#39; =\u0026gt; 1024, \u0026#39;M\u0026#39; =\u0026gt; 1048576, \u0026#39;G\u0026#39; =\u0026gt; 1073741824]; // 오류 처리는 생략했습니다. preg_match(\u0026#39;/^(\\d+)([KMG])$/i\u0026#39;, $value, $matches); return $matches[1] * $sizeTable[strtoupper($matches[2])]; } $parser = new Console_CommandLine(); $parser-\u0026gt;addOption( \u0026#39;size\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-s\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;Callback\u0026#39;, \u0026#39;callback\u0026#39; =\u0026gt; \u0026#39;getByteSize\u0026#39;, ] ); Callback 옵션은 인자 값을 콜백 함수를 통해 전처리하도록 합니다. 예제는 \u0026lsquo;10G\u0026rsquo;, \u0026lsquo;8M\u0026rsquo; 같이 단위를 붙인 크기값을 바이트 단위로 변환하는 코드입니다.\nTrue, False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $parser-\u0026gt;addOption( \u0026#39;debug\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-d\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreTrue\u0026#39;, ] ); $parser-\u0026gt;addOption( \u0026#39;quiet\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-q\u0026#39;, \u0026#39;default\u0026#39; =\u0026gt; true, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreFalse\u0026#39;, ] ); True, False 옵션은 명령행 인자로 해당 옵션이 주어졌을 때 true 또는 false 값을 저장하도록 합니다. default를 생략한 경우, 옵션을 사용하지 않으면 null 값이 저장됩니다.\n인자, 서브커맨드 프로그램이 인자(Argument)를 받아들이기 위해서는 addArgument() 메소드를 이용해 인자에 대한 정보를 매개변수로 전달해야 합니다.\n1 2 3 4 5 6 7 8 $parser-\u0026gt;addArgument( \u0026#39;INPUT\u0026#39;, [ \u0026#39;multiple\u0026#39; =\u0026gt; true, \u0026#39;optional\u0026#39; =\u0026gt; true, ] ); $parser-\u0026gt;addArgument(\u0026#39;OUTPUT\u0026#39;, []); 위 코드는 INPUT과 OUTPUT 인자를 받을 수 있도록 한 것입니다. 여기서 multiple은 해당 인자가 여러 개 올 수 있다는 것이고, optional은 생략이 가능하다는 의미입니다. 바꿔말해 INPUT 인자는 생략하거나 여러개를 쓸 수 있고, OUTPUT은 반드시 하나만 입력해야 한다는 것입니다.\n1 2 3 4 5 6 7 8 9 Usage: example-10.php [options] [INPUT1 INPUT2 ...] OUTPUT Options: -h, --help show this help message and exit Arguments: INPUT OUTPUT 도움말을 통해 이를 다시 확인 해보면 생략 가능하다는 의미로 대괄호로 INPUT을 감싸고 있고, 여러개 사용이 가능하다는 의미로 뒤에 숫자를 붙인 후 말줄임표를 뒤에 덧붙입니다.\n서브커맨드(Subcommand)는 git처럼 프로그램 실행시 사용 할 수 있는 보조적인 명령어입니다. 예를 들면 git clone ... 같은 명령어에서 clone 부분이 서브커맨드입니다. 서브커맨드가 옵션이나 인자와 다른 점은 서브커맨드 자체적인 옵션과 인자를 가질 수 있다는 것입니다. 바꿔말해 -a 옵션을 그냥 사용했을 때와 서브커맨드 뒤에 붙여서 사용 했을 때 동작이 서로 다르게 할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $copy = $parser-\u0026gt;addCommand(\u0026#39;list\u0026#39;); $copy-\u0026gt;addOption( \u0026#39;all\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-a\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreTrue\u0026#39;, ] ); $remove = $parser-\u0026gt;addCommand(\u0026#39;remove\u0026#39;); $remove-\u0026gt;addOption( \u0026#39;recursive\u0026#39;, [ \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-r\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreTrue\u0026#39; ] ); $result = $parser-\u0026gt;parse(); var_dump($result-\u0026gt;command_name); var_dump($result-\u0026gt;command-\u0026gt;options); var_dump($result-\u0026gt;command-\u0026gt;args); 위 코드는 list와 remove 두개의 서브커맨드를 설정하고 있습니다. list는 -a 옵션을, remove는 -r 옵션을 가지고 있습니다.\n1 2 php ./example-11.php list -a php ./example-11.php remove -r 위처럼 사용하는 것은 가능하지만, php ./example-11.php list -r은 에러를 냅니다.\n어떤 서브커맨드를 사용했는지 확인하기 위해서는 Console_CommandLine_Result 인스턴스의 command_name 프로퍼티 값을 이용하면 됩니다. 또한, 서브커맨드에 사용된 옵션과 인자는 동일한 인스턴스의 command 프로퍼티를 이용합니다. command는 서브커맨드에 대한 Console_CommandLine_Result 인스턴스입니다.\n사용자 정의 특별한 형식을 가진 옵션을 받는 경우가 종종 있습니다. 예를 들면 IP 같은 것 말입니다. 보통의 경우 IP를 문자열로 받은 후에 문자열이 올바른 IP인지 검사를 합니다만, PEAR Console_CommandLine에서는 Action을 사용자 정의하여 조금 더 깔끔하고 통일된 형태로 이를 처리 할 수 있습니다.\n소스 코드를 설명드리기 전에 첫번째 글에서 보여드렸던 Composer로 PEAR 패키지를 설치하는 방식 대신에 Packagist를 통해 설치하는 것을 보여드리려고 합니다.\n1 composer require pear/console_commandline 위의 명령은 다음과 같은 내용을 가진 composer.json을 생성합니다.\n1 2 3 4 5 { \u0026#34;require\u0026#34;: { \u0026#34;pear/console_commandline\u0026#34;: \u0026#34;^1.2\u0026#34; } } composer를 통해 CommandLine을 설치했으면, 이제 옵션으로 IP를 입력받는 예제 소스 코드를 살펴 보도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php require \u0026#39;vendor/autoload.php\u0026#39;; class ActionIP extends Console_CommandLine_Action { public function execute($value=false, $params=array()) { if (ip2long($value) === false) { throw new Exception(\u0026#39;Invalid IP\u0026#39;); } $this-\u0026gt;setResult($value); } } Console_CommandLine::registerAction(\u0026#39;StoreIP\u0026#39;, \u0026#39;ActionIP\u0026#39;); $parser = new Console_CommandLine(); $parser-\u0026gt;addOption( \u0026#39;ip\u0026#39;, array( \u0026#39;short_name\u0026#39; =\u0026gt; \u0026#39;-i\u0026#39;, \u0026#39;long_name\u0026#39; =\u0026gt; \u0026#39;--ip\u0026#39;, \u0026#39;description\u0026#39; =\u0026gt; \u0026#39;IP Address\u0026#39;, \u0026#39;help_name\u0026#39; =\u0026gt; \u0026#39;IP\u0026#39;, \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;StoreIP\u0026#39; ) ); try { $result = $parser-\u0026gt;parse(); print_r($result-\u0026gt;options); } catch (Exception $e) { $parser-\u0026gt;displayError($e-\u0026gt;getMessage()); }; 우선 액션을 정의하기 위해서는 Console_CommandLine_Action 클래스를 상속받은 클래스를 하나 정의해야 합니다. 여기서는 일관성을 위해 Action으로 시작하는 ActionIP 클래스를 정의 해 보겠습니다. 이 클래스는 public인 execute 메소드를 정의해야 합니다. execute 메소드는 옵션의 값을 첫번째 파라미터 $value로 넘겨줍니다. 이 value를 검사하고, 필요하다면 적절히 변형하여 $this-\u0026gt;setResult($value)를 통해 값을 저장하면 내장된 다른 Store 계열 액션들과 마찬가지로 사용 할 수 있게 됩니다.\n액션을 처리 할 클래스를 정의했다면 이 클래스를 Consol_CommandLine에 등록을 시켜주어야 합니다. 이를 처리하는 정적 메소드는 Console_CommandLine::registerAction으로 첫번째는 옵션을 정의 할 때 쓸 액션의 이름을 받고, 두번째는 액션을 정의한 클래스명을 받습니다.\n이렇게 액션을 처리하는 클래스를 정의하고 이를 등록시켜 준 후, 내장된 액션들처럼 자유롭게 사용이 가능해집니다.\n","permalink":"https://sangheonhan.github.io/pear-console_commandline/","summary":"설치 Console_CommandLine 패키지는 명령행 인자를 파싱하는 PEAR 라이브러리입니다. 컴포져를 이용해서 설치하려면 composer.json에 다음 내용을 알맞은 위치에 추가하면 됩","title":"PEAR: Console_CommandLine"},{"content":"우분투(Ubuntu)에서 커널 업데이트를 하고나면 virtualbox 서비스가 오류를 내는 문제가 생깁니다. virtualbox 서비스를 실행하지 못 했기 때문에 VirtualBox에서 가상 머신을 시작 할 수 없습니다. 이virtualbox-dkms 패키지를 아래와 같은 방법으로 재설치하면 이 문제를 해결 할 수 있습니다.\n1 2 3 sudo aptitude install build-essential libssl-dev linux-headers-`uname -r` sudo aptitude reinstall dkms sudo aptitude reinstall virtualbox-dkms ","permalink":"https://sangheonhan.github.io/%EC%9A%B0%EB%B6%84%ED%88%AC-%EC%BB%A4%EB%84%90-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%9B%84-virtualbox-%EC%8B%A4%ED%96%89-%EC%98%A4%EB%A5%98/","summary":"우분투(Ubuntu)에서 커널 업데이트를 하고나면 virtualbox 서비스가 오류를 내는 문제가 생깁니다. virtualbox 서비스를 실행하지 못 했기 때문에 VirtualBox에서 가","title":"우분투 커널 업데이트 후 VirtualBox 실행 오류"},{"content":"기본사용법 대부분의 프로그래밍 언어는 여러 모듈과 라이브러리를 관리하기 위한 시스템을 가지고 있다. PHP는 PEAR(PHP Extension and Application Repository)라는 시스템을 가지고 있는데, 현재는 컴포져(Composer)에 밀려나는 중이다. 모던 PHP(Modern PHP)를 위해서라도 컴포져를 쓰는 것이 더 좋겠지만, 때로 아직은 PEAR를 써야 할 일이 종종 있다. 물론 이 경우라도 컴포져를 통해서 PEAR를 사용하는 것을 적극 권장한다. 컴포져를 이용해 PEAR를 사용하는 방법은 컴포져 설명서에 자세히 나와있다.\nPHP를 설치하면 기본적으로 설치되는 PEAR 패키지가 몇개 있는데 Log도 그 중 하나다. 배포판에 따라 설치되지 않는 경우도 있지만, sudo pear install Log 명령을 통해서 간단히 설치 가능한다. 하지만 현재 Monolog가 쓰이는 경우가 더 많으므로, 새로운 프로젝트라면 그것을 쓰는 것을 더 추천하고 싶다.\n예제를 통해서 Log 패키지 사용법을 하나씩 살펴보자.\n1 2 3 4 5 6 7 \u0026lt;?php require_once \u0026#39;Log.php\u0026#39;; $logger = Log::factory(\u0026#39;console\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;foobar\u0026#39;); $logger-\u0026gt;log(\u0026#39;Hello\u0026#39;); 1 require_once \u0026#39;Log.php\u0026#39;; Log 패키지를 사용하기 위해서는 Log.php를 읽어들여야 하는데, PEAR를 통해서 설치했다면 보통 include_path로 잡혀있기 때문에 경로 없이 파일만 지정하면 된다. 컴포져를 통해서 설치했다면 vendor/autoload.php를 로드하면 된다.\n1 $logger = Log::factory(\u0026#39;console\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;foobar\u0026#39;); Log 인스턴스를 하나 생성한다. 여기서는 Log::factory를 이용했다. 또 다른 방법으로 singleton 메소를 사용 할 수도 있는데, factory는 일반적으로 Log 인스턴스를 여럿 생성하기 위해 사용하고, singleton은 오직 하나의 Log 인스턴스만 생성하고 싶을 때 사용한다.\n1 Log::factory($handler, $name, $ident, $conf, $maxLevel); 첫번째 매개변수 console은 화면에 로그 메시지를 출력하는 핸들러 생성을 의미한다. 두번째는 로그 리소스의 이름으로 기본값은 빈 문자열이다. 여기서는 기본값을 그대로 사용했다. 세번째는 로그 파일 내에 기록되는 identification string으로 같은 로그 파일 내에 여러 종류의 로그 메시지들이 기록될 때 서로 구분하기 위해 사용하는 고유한 문자열이다. 네번째와 다섯번째는 핸들러 설정을 위한 배열과 기록 할 로그 레벨을 정하기 위한 값인데, 생략하면 기본값을 사용한다.\n1 $logger-\u0026gt;log(\u0026#39;Hello\u0026#39;); Log 인스턴스의 log 메소드를 통해서 로그 메시지를 기록한다. 두번째 메소드로 로그 레벨을 지정 할 수 있는데, 생략 할 경우 기본값인 PEAR_LOG_INFO를 로그 레벨로 사용한다.\nsingleton 메소드를 통해 Log 인스턴스를 생성하는 방법은 factory 메소드와 동일하지만, 둘의 차이는 singleton 경우는 여러번 인스턴스를 생성하더라도 오직 하나의 인스턴스를 생성한다는 점이다. 보통의 경우라면 factory 보다 singleton이 더 적절하다.\n1 $logger = Log::singleton(\u0026#39;file\u0026#39;, \u0026#39;foobar.log\u0026#39;, \u0026#39;foobar\u0026#39;); singleton 메소드의 사용법은 factory 메소드와 동일하다. 다만, 여기서는 로그 핸들러를 console이 아닌 file을 사용했다. file 로그 핸들러를 사용하면 메시지를 텍스트 파일로 저장한다. 파일로 저장하기 때문에 두번째 매개변수에 로그 파일명이 들어간다.\n로그 레벨 로그 메시지에는 로그 레벨이란 것이 있는데, 대부분의 유닉스 계열의 로그 시스템에서 거의 동일하게 사용한다. Log에서도 마찬가지로 동일한 로그 레벨을 사용 중이고, Monolog, PSR-3, syslog를 사용한다고 해도 이 부분은 거의 같다.\nLog 사용자 문서에 나온 로그 레벨 표를 일단 한 번 살펴보자.\nLevel Shortcut Description PEAR_LOG_EMERG emerg() System is unusable PEAR_LOG_ALERT alert() Immediate action required PEAR_LOG_CRIT crit() Critical conditions PEAR_LOG_ERR err() Error conditions PEAR_LOG_WARNING warning() Warning conditions PEAR_LOG_NOTICE notice() Normal but significant PEAR_LOG_INFO info() Informational PEAR_LOG_DEBUG debug() Debug-level messages Level 값은 PEAR Log 패키지가 미리 정의한 값으로 log() 메소드 두번째 매개변수에 들어간다. 첨언하자면 PEAR_LOG_DEBUG가 가장 낮고, PEAR_LOG_EMERG가 가장 높은 레벨이다. 매번 log() 메소드에 로그 레벨 상수를 넣는 것이 번거롭다면 숏컷(Shortcut)을 사용 할 수도 있다.\n1 2 $logger-\u0026gt;log(\u0026#39;Hello\u0026#39;, PEAR_LOG_DEBUG); $logger-\u0026gt;debug(\u0026#39;Hello\u0026#39;); // 위 문장과 동일하게 동작한다. 로그 레벨을 구별해서 기록하고 싶다면, Log 인스턴스를 생성 할 때 어느 로그 레벨 이상만 기록할지 지정 할 수 있다.\n1 $logger = Log::singleton(\u0026#39;file\u0026#39;, \u0026#39;levels.log\u0026#39;, \u0026#39;factorial\u0026#39;, null, PEAR_LOG_ERR); 5번째 매개변수에 로그 레벨 상수를 넣으면 해당 로그 레벨 이상인 메시지만 해당 로그 리소스에 기록한다.\n이미 생성한 Log 인스턴스를 특정 로그 레벨들만 기록하게 하고 싶다면 setMask() 메소드를 통해 로그 레벨을 지정하면 된다.\n1 2 $mask = Log::MASK(PEAR_LOG_WARNING) | Log::MASK(PEAR_LOG_INFO); $logger-\u0026gt;setMask($mask); // Warning, Information 만 기록한다. 특정 로그 레벨 이상 또는 이하만 기록하고 싶다면 MAX(), MIN() 메소드를 이용한다.\n1 2 $mask = Log::MAX(PEAR_LOG_CRIT); // Critical 이상만 기록한다. $mask = Log::MIN(PEAR_LOG_NOTICE); // Notice 이하만 기록한다. 특정 로그 레벨을 제외한 나머지 로그 레벨들을 기록하려고 한다면 ^ 연산자를 이용해 마스크(Mask)를 지정한다.\n1 $mask = PEAR_LOG_ALL ^ Log::MASK(PEAR_LOG_WARNING); // Warning 뺀 나머지 로그 레벨들을 기록한다. Log 인스턴스에 특정 로그 레벨을 추가적으로 기록하고 싶다면 getMask() 메소드와 | 연산자를 이용해 마스크를 지정한다.\n1 2 // 기록 중인 로그 레벨과 더불어 Warning 도 기록하게 한다. $mask = $logger-\u0026gt;getMask() | Log::MASK(PEAR_LOG_WARNING); 로그 라인 포맷 Log 인스턴스를 생성 할 때 설정값을 통해서 로그 라인의 형식을 기본 외의 형식으로 지정 할 수 있다. 형식에 사용하는 토큰은 다음과 같다.\nToken Alternate Description %{timestamp} %1$s Timestamp. This is often configurable. %{ident} %2$s The log handler\u0026rsquo;s identification string. %{priority} %3$s The log event\u0026rsquo;s priority. %{message} %4$s The log event\u0026rsquo;s message text. %{file} %5$s The full filename of the logging file. %{line} %6$s The line number on which the event occured. %{function} %7$s The function from which the event occurred. %{class} %8$s The class in which the event occurred. 토큰을 이용해 정의한 로그 라인 형식은 Log 인스턴스 생성시 설정값 매개변수에 lineFormat 첨자로 전달한다.\n1 2 3 4 5 $conf = array( \u0026#39;lineFormat\u0026#39; =\u0026gt; \u0026#39;%{timestamp} %{ident} %{priority} %{message} %{file} %{line} %{function} %{class}\u0026#39;, ); $logger = Log::singleton(\u0026#39;file\u0026#39;, \u0026#39;foobar.log\u0026#39;, \u0026#39;foobar\u0026#39;, $conf); 로그 핸들러 Log 패키지에서 제공하는 다수의 로그 핸들러가 있다. 그 중 이전 글에서 다룬 console과 file 제외하고 몇개를 추려 간략한 사용법을 살펴보자.\nFirebug firebug 로그 핸들러는 파이어폭스(Firefox) Firebug 애드온의 콘솔 패널을 통해 로그 메시지를 출력하는 핸들러다.\n1 $logger = Log::singleton(\u0026#39;firebug\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;foobar\u0026#39;); SQL sql 로그 핸들러는 데이터베이스에 로그 메시지를 기록한다. 데이터베이스 접근은 Log 패키지 안에서 PEAR DB를 이용한다. sql 핸들러를 사용하기 위해서는 로그를 저장 할 테이블을 미리 만들어야 한다. 기본값으로 사용하는 테이블 스키마는 다음과 같다.\n1 2 3 4 5 6 7 8 CREATE TABLE log_table ( id INT NOT NULL, logtime TIMESTAMP NOT NULL, ident CHAR(16) NOT NULL, priority INT NOT NULL, message VARCHAR(200), PRIMARY KEY (id) ); dsn은 사용하는 DBMS와 계정, 데이터베이스에 따라 설정한다. 자세한 형식은 DSN 문서에 나와있다.\n1 2 $conf = array(\u0026#39;dsn\u0026#39; =\u0026gt; \u0026#39;mysql://bookworm@localhost/test\u0026#39;); $logger = Log::singleton(\u0026#39;sql\u0026#39;, \u0026#39;log_table\u0026#39;, \u0026#39;foobar\u0026#39;, $conf); Syslog syslog 핸들러는 syslog 데몬을 통해서 로그 메시지를 기록한다. 정상적으로 기록하기 위해서는 syslog 데몬 설정을 미리 해두어야 한다.\n1 $logger = Log::singleton(\u0026#39;syslog\u0026#39;, LOG_LOCAL0, \u0026#39;foobar\u0026#39;); Window win 핸들러는 웹브라우저에 새 창을 만든 후 그 안에 로그 메시지를 출력한다.\n1 2 $conf = array(\u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Log Window\u0026#39;); $logger = Log::singleton(\u0026#39;win\u0026#39;, \u0026#39;LogWindow\u0026#39;, \u0026#39;foobar\u0026#39;, $conf); Composite composite 핸들러는 독립적으로 동작하지 않고, 다른 로그 핸들러를 통해서 메시지를 출력하도록 해준다. 이를 통해 여러 로그 리소스에 같은 메시지를 기록 할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php require \u0026#39;Log.php\u0026#39;; $console = Log::singleton(\u0026#39;console\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;foobar\u0026#39;); $file = Log::singleton(\u0026#39;file\u0026#39;, \u0026#39;foobar.log\u0026#39;, \u0026#39;foobar\u0026#39;); $logger = Log::singleton(\u0026#39;composite\u0026#39;); $logger-\u0026gt;addChild($console); // console 로그 리소스를 composite 핸들러에 추가한다. $logger-\u0026gt;addChild($file); // file 로그 리소스를 composite 핸들러에 추가한다. $logger-\u0026gt;log(\u0026#39;Hello\u0026#39;); // console과 file 로그 둘 다 출력한다. $logger-\u0026gt;removeChild($console); $logger-\u0026gt;log(\u0026#39;Goodbye\u0026#39;); // console을 제거했기 때문에 file 로그에만 출력한다. 컴포져로 설치하기 컴포져(Composer)로 PEAR 패키지를 설치하는 일반적인 방법은 컴포져 설명서에 나와있으므로, 여기서는 Log 패키지에 한정해서 이야기를 해보려고 한다.\n패키지스트(Packagist)에 이미 pear/log가 있으므로 require로 손쉽게 설치 할 수 있었다. 하지만, 언젠가부터 의존성 문제로 설치가 되지 않는다. 이 문제를 해결하기 위해서는 composer.json에 dev-master 패키지를 설치하도록 설정해야 한다.\n1 2 3 4 5 6 { \u0026#34;require\u0026#34;: { \u0026#34;pear/log\u0026#34;: \u0026#34;dev-master\u0026#34;, \u0026#34;pear/pear_exception\u0026#34;: \u0026#34;1.0.*@dev\u0026#34; } } PEAR Log 의존성 문제를 없애기 위해 PEAR_Exception 패키지로 함께 설치하도록 설정했다.\n지금까지 PEAR의 Log 패키지에 대해 간략하게 다뤄보았다. 자세한 설정이나 기능에 대해서는 Log 패키지 문서를 통해 살펴 볼 수 있다.\n","permalink":"https://sangheonhan.github.io/pear-log/","summary":"기본사용법 대부분의 프로그래밍 언어는 여러 모듈과 라이브러리를 관리하기 위한 시스템을 가지고 있다. PHP는 PEAR(PHP Extension and Application Repository)라는 시스템을 가","title":"PEAR: Log"},{"content":"개발을 하다 보면 지속적으로 반복해서 처리해야 하는 작업을 만날 때가 있다. 이런 경우 데몬으로 만들어서 터미널이 종료되더라도 항상 백그라운드에서 돌아가도록 하면 된다. 조금 더 정성을 기울인다면 ntsysv나 update-rc.d 같은 도구를 사용해 부팅시 자동으로 실행되도록 한다.\n하지만 단순한 스크립트 작업을 데몬으로 만드는 것은 배보다 배꼽이 더 클뿐더러 단지 반복적으로만 실행하면 되는 경우가 많기 때문에 1분마다 crond를 통해 실행하도록 하는 방법도 자주 사용한다. 다만 이 경우 중복 실행을 막기 위해 잠금 파일(lockfile)을 통해 기존에 실행 중인 같은 스크립트가 있는지 확인하는 절차가 필요하다. 이 방법의 아쉬운 점은 실행 시간이 1분 단위이기 때문에 그 이하로 빈번히 동작해야 하는 스크립트에는 적용하기 어렵다는 단점있다.\n이런 단점을 해결하고 좀 더 손쉽게 스크립트(또는 프로세스)를 항상 실행 할 수 있도록 하는데 도움이 되는 도구들이 있다. 여기서는 널리 쓰이는 데몬툴즈(daemontools)를 이용해 스크립트를 항상 실행하는 방법을 정리 해 보았다.\n우선 데몬툴즈를 설치해야 한다. 설치 환경은 우분투 12.04를 기준으로 했다.\n1 2 sudo aptitude install daemontools sudo aptitude install daemontools-run 그 다음은 데몬툴즈의 서비스(service) 디렉토리를 살펴보고 run 스크립트를 찾아 실행시켜주는 svscan 서비스를 띄운다.\n1 2 sudo service svscan start pgrep -fl svscan svscan 서비스가 동작하기 시작하면 /etc/service 디렉토리 안에 run 스크립트 파일을 찾아 supervise 도구를 이용해서 항시 run 스크립트가 실행되도록 자동으로 처리한다.\n데몬툴즈의 기본 디렉토리는 /etc/service 이므로, 테스트를 위해 이 안에 foobar 디렉토리를 만든다.\n1 2 3 cd /etc/service sudo mkdir foobar cd foobar 그 다음 run.new 파일을 다음 내용으로 생성한다.\n1 2 3 #! /bin/sh date \u0026gt;\u0026gt; /tmp/date.log 파일을 생성했으면 실행권한을 부여하고, run으로 이름을 변경한다. 이렇게 하는 이유는 supervise에 의해 언제 run 스크립트가 실행될지 모르므로 편집 중간에 실행되는 것을 방지하기 위해서다.\n1 2 sudo chmod 755 run.new sudo mv run.new run run으로 이름을 바꾸면 바로 supervise가 run 파일을 실행하는 것을 확인 할 수 있다.\n1 2 pgrep -fl supervise tail -f /tmp/date.log 이렇게 실행한 run 스크립트는 svstat 명령을 이용해 동작 중인 것을 확인 할 수 있다. svstat을 사용하면 다른 관리 스크립트에서 실행 여부를 모니터링 하는데 유용하다.\n1 sudo svstat /etc/service/foobar 만약 실행 중인 스크립트를 중지시키거나 시작 또는 재시작 하고 싶은 경우 svc 명령을 사용하면 된다. -u는 시작, -d는 중지다.\n1 2 sudo svc -u /etc/service/foobar sudo svc -d /etc/service/foobar 이 외에도 데몬툴즈에는 유용한 도구 및 기능들이 다수 포함되어 있으므로 다양하게 활용 가능하다.\n","permalink":"https://sangheonhan.github.io/%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%95%AD%EC%83%81-%EB%9D%84%EC%9B%8C%EB%86%93%EA%B8%B0/","summary":"개발을 하다 보면 지속적으로 반복해서 처리해야 하는 작업을 만날 때가 있다. 이런 경우 데몬으로 만들어서 터미널이 종료되더라도 항상 백그라운드에서 돌아가도록 하면","title":"스크립트(프로세스) 항상 띄워놓기"},{"content":"gcc 컴파일러는 -S 옵션을 이용해 어셈블리어로 실제 C 언어의 내부 동작을 살펴 볼 수 있다. 하지만 PHP는 기본적으로 그러한 기능이 없으나, pthreads 모듈을 만든 Joe Watkins가 만든 explain이라는 모듈을 통해 어느 정도 PHP 내부 동작을 파악 할 수 있게 됐다.\n일단 explain 확장 모듈을 설치해야 한다.\n1 2 3 4 5 6 7 wget https://github.com/krakjoe/explain/archive/master.tar.gz -O explain.tar.gz tar -xvzf explain.tar.gz cd explain-master phpize ./configure make make install 설치 후 자신의 환경에 맞춰 explain.ini 파일을 만들고 아래 내용을 넣는다.\n1 extension=explain.so 만약 phpbrew를 사용한다면 간단히 phpbrew ext enable explain 명령으로 모듈을 활성화 할 수 있다. 다음 명령으로 explain 모듈이 활성화 됐는지 확인한다.\n1 php -m | grep explain explain 모듈 사용법은 explain-master 안에 있는 explain.php를 통해 타겟 php 파일 또는 디렉토리를 지정하면 된다.\n적당한 디렉토리를 하나 만들고 예제로 쓸 두 파일을 만든다.\n1 2 \u0026lt;?php echo \u0026#34;Hello world\\n\u0026#34;; 1 2 \u0026lt;?php print \u0026#34;Hello world\\n\u0026#34;; 그리고 아래 명령을 실행한다.\n1 php ../explain-master/explain.php . \u0026gt; echo_vs_print.html 실행을 하고 나면 echo_vs_print.html 파일이 생긴다. 브라우징에 필요한 자바스크립트 파일을 복사해온다.\n1 cp -r ../explain-master/assets . 웹브라우저로 echo_vs_print.html 파일을 열어보자.\n두 파일의 내용을 비교해보면 print는 반환값을 가지고 있기 때문에 1개의 명령을 더 실행하는 것을 알 수 있다.\n아쉬운 점은 Zend 명령으로 변환된 것을 보여주기 때문에 동적으로 처리되는 경우까지 완벽히 파악하기는 어렵다는 것이다. 하지만 PHP 내부 동작을 이해하는데 큰 도움이 될뿐더러 특히 확장 모듈을 개발하려는 개발자에게는 더욱 유용하리라 예상된다.\n","permalink":"https://sangheonhan.github.io/php-%EB%82%B4%EB%B6%80-%EB%8F%99%EC%9E%91-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0/","summary":"gcc 컴파일러는 -S 옵션을 이용해 어셈블리어로 실제 C 언어의 내부 동작을 살펴 볼 수 있다. 하지만 PHP는 기본적으로 그러한 기능이 없으나, pthreads 모듈을 만든 Joe Watk","title":"PHP 내부 동작 들여다보기"},{"content":"C 언어로 개발하다 보면 헤더 파일들끼리 의존성이 생겨나는데, 그 수가 적을 때는 수동으로 Makefile에 적어도 되지만 많아질 경우 수동으로 하기는 곤란해진다. 이럴 때 gccmakedep이라는 도구를 사용하면 자동으로 이런 헤더 사이 의존관계를 처리 할 수 있다. 최근에는 gccmakedep이 없는 경우가 보통이라 gcc -M 옵션을 사용하는 것을 더 추천한다.\n문제는 이렇게 만든 의존 관계를 Makefile에 포함시킬 경우 git 같은 도구에서 업데이트를 한 것으로 처리하기 때문에 깔끔하지 않다. 왜냐하면 의존 관계는 환경에 따라 얼마든지 다르기 때문에 각 컴파일 환경에 따라 매번 새로 갱신을 해야하는 내용이기 때문이다.\n이런 경우 의존 관계를 별도의 파일로 생성을 해서 처리하고, 해당 파일은 .gitignore에 포함시키면 깔끔하게 관리 할 수 있다.\n1 2 3 4 5 6 dep : gcc -M $(INC) $(SRCS) \u0026gt; .depend ifeq (.depend,$(wildcard .depend)) include .depend endif ","permalink":"https://sangheonhan.github.io/c-%EC%96%B8%EC%96%B4-%ED%97%A4%EB%8D%94-%ED%8C%8C%EC%9D%BC-%EA%B0%84-%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0/","summary":"C 언어로 개발하다 보면 헤더 파일들끼리 의존성이 생겨나는데, 그 수가 적을 때는 수동으로 Makefile에 적어도 되지만 많아질 경우 수동으로 하기는 곤란해진다","title":"C 언어 헤더 파일 간 의존 관계 빌드하기"},{"content":"평소 크게 신경을 쓰던 문제는 아닌데 이번에 관련 작업을 하면서 이게 간단한 문제는 아니라는 것을 알게 됐다. 이 문제가 어려운 이유는 그 해의 몇 주차인지에 대해서는 ISO 표준이 있는데, 월의 몇 주차인지에 대해서는 표준이 없기 때문이다. 아마 표준이 있었으면 이미 날짜 관련 함수 중에 있었을 것이다.\n본격적으로 이야기를 꺼내기 전에 주(week)에 관한 ISO 표준 중 관련 사항을 알아 보자.\n한 주의 시작은 월요일이다.\n달력에 일요일부터 표시하고 있기 때문에 한 주 시작이 일요일 같지만 월요일이 표준이라고 한다. 즉, 한 주는 월요일로 시작 해 일요일로 끝난다.\n년도의 주차는 해당 주의 목요일 년도에 따라간다.\n예를 들어 1월 1일이 목요일이면, 12월 31일(수), 12월 30일(화), 12월 29일(월)은 전년도에 포함되지 않고 이번 년도의 1주차에 포함된다. 반대로 1월 1일이 금요일이면 1월 1일(금), 1월 2일(토), 1월 3일(일)은 전년도 마지막 주차에 포함된다.\n그럼 월의 주차를 계산하는 방법은 어떨까?\n아주 다양한 계산법들이 있지만 그 중 널리 쓰이는 계산법을 몇가지 살펴보자.\n년의 주차 계산과 동일한 방법\n즉, 목요일이 어느 달에 속하느냐를 따져 전달에 마지막 주차에 포함시키거나 이번 달 첫 주차에 포함시킨다.\n월요일을 기준으로 하는 방법\n월요일에 어느 달에 포함되느냐에 따른다. 월요일이 31일이면 그 뒤에 나오는 1, 2, 3, 4, 5, 6일은 마지막 주차에 포함시킨다.\n각 달에 포함하는 방법\n30일이 월요일인 경우 30일(월), 31일(화)는 전 달의 마지막 주차로 계산하고, 1일(수), 2일(목), 3일(금), 4일(토), 5일(일)은 이번 달 첫 주차로 계산하는 방법이다.\n그럼 어떤 방법으로 월의 주차를 계산해야 할까? 여기서는 첫번째 년의 주차 계산과 동일한 방법으로 계산하기로 하자. 이렇게 한 이유는 다른 계산법으로 하는 경우 년의 주차로는 1 주차면서 12월의 마지막 주차로 계산되는 불일치가 나타날 수 있기 때문이다. 이런 불일치는 다른 파생적인 문제와 예외 처리가 필요 할 수 있기 때문에, 년의 주차 계산과 동일한 방법으로 월의 주차를 계산하려고 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;?php class DateTimeExtra extends DateTime { public function weekofmonth() { $thursday = $this-\u0026gt;thursday(); if ( $thursday-\u0026gt;format(\u0026#39;n\u0026#39;) != $this-\u0026gt;format(\u0026#39;n\u0026#39;) ) { $date = $thursday; } else { $date = $this; } $firstday = clone $date; $firstday-\u0026gt;sub(new DateInterval(\u0026#39;P\u0026#39;.($date-\u0026gt;format(\u0026#39;j\u0026#39;) - 1).\u0026#39;D\u0026#39;)); $thursday_of_firstday = $firstday-\u0026gt;thursday(); if ( $thursday_of_firstday-\u0026gt;format(\u0026#39;n\u0026#39;) != $firstday-\u0026gt;format(\u0026#39;n\u0026#39;) ) { // 이번 달 첫번째 날을 포함한 주의 목요일의 월과 첫번째 날의 월이 // 다른 경우는 첫번째 날이 이전 달의 마지막 주에 포함되어 있다는 // 것이므로 월의 주차 기준이 되는 주를 한 주 뒤로 미룬다. $firstday-\u0026gt;add(new DateInterval(\u0026#39;P1W\u0026#39;)); } $month = $date-\u0026gt;format(\u0026#39;n\u0026#39;); $weekofmonth = $date-\u0026gt;format(\u0026#39;W\u0026#39;) - $firstday-\u0026gt;format(\u0026#39;W\u0026#39;) + 1; return array(intval($month), intval($weekofmonth)); } private function thursday() { $thursday = clone $this; $dayofweek = $this-\u0026gt;format(\u0026#39;N\u0026#39;); if ( $dayofweek \u0026lt; 4 ) { $thursday-\u0026gt;add(new DateInterval(\u0026#39;P\u0026#39;.(4 - $dayofweek).\u0026#39;D\u0026#39;)); } if ( $dayofweek \u0026gt; 4 ) { $thursday-\u0026gt;sub(new DateInterval(\u0026#39;P\u0026#39;.($dayofweek - 4).\u0026#39;D\u0026#39;)); } return $thursday; } } ?\u0026gt; 월의 주차의 계산은 이렇게 했다. 우선 특정일이 속한 주의 목요일과 특정일이 속한 월의 1일이 속한 주의 목요일을 구한다. 그리고 이 둘의 월을 비교한다. 서로 다르면 이번 달의 1일이 속한 주가 전 달의 마지막 주차에 포함된 것이므로 이번 달의 시작인 년의 주차를 한 주 미룬다. 같으면 이번 달 1일이 포함된 주차가 이번 달의 첫 주차이므로 그대로 사용한다. 이 둘의 년의 주차를 빼주면 특정일의 해당 월의 주차를 구할 수 있다.\n","permalink":"https://sangheonhan.github.io/%EC%9B%94%EC%9D%98-%EB%AA%87-%EC%A3%BC%EC%B0%A8%EC%9D%B8%EC%A7%80-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/","summary":"평소 크게 신경을 쓰던 문제는 아닌데 이번에 관련 작업을 하면서 이게 간단한 문제는 아니라는 것을 알게 됐다. 이 문제가 어려운 이유는 그 해의 몇 주차인지에 대해서는 ISO 표","title":"월의 몇 주차인지 계산하기"},{"content":"InnoDB를 사용하면서 동시성(Concurrency)을 고려하지 않고 개발을 하면 큰 문제가 생길 수 있다. 아래에 게임 속 플레이어 간 골드를 넘기는 간단한 로직을 살펴보자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php $pdo = new PDO(\u0026#39;mysql:host=localhost;dbname=test\u0026#39;, \u0026#39;bookworm\u0026#39;, \u0026#39;\u0026#39;); try { $pdo-\u0026gt;beginTransaction(); foreach ($pdo-\u0026gt;query(\u0026#39;SELECT gold FROM players WHERE id = 1\u0026#39;) as $row) { if ($row[\u0026#39;gold\u0026#39;] \u0026lt; 1000) { echo \u0026#34;Not enough gold.\\n\u0026#34;; exit; } } $pdo-\u0026gt;query(\u0026#39;UPDATE players SET gold = gold - 1000 WHERE id = 1\u0026#39;); $pdo-\u0026gt;query(\u0026#39;UPDATE players SET gold = gold + 1000 WHERE id = 2\u0026#39;); $pdo-\u0026gt;commit(); } catch (Exception $e) { $pdo-\u0026gt;rollBack(); } $pdo = null; ?\u0026gt; 위 예제 코드는 한 플레이어의 골드를 다른 플레이어에게 주는 로직을 간략하게 한 것이다. 이 코드가 동시에 하나씩 실행되면 문제가 없지만, 그렇지 않은 경우 버그가 발생한다. 우선 한 플레이어의 골드가 옮기려는 1000 골드 이상인지 확인 후 1000 골드를 차감한다. 그 후 받을 플레이어의 골드를 1000 증가시킨 후 트랜잭션을 커밋한다. 만약 커밋이나 롤백을 하기 전에 다른 프로세스가 플레이어 1번의 골드를 조회하는 경우 차감 전의 원래 골드 값을 돌려받아 버그가 생기게 된다.\n이를 방지하기 위해서는 InnoDB의 기본 \u0026lsquo;Isolation Level\u0026rsquo;를 변경 할 수 있겠지만, 전체 쿼리 중 동시성을 고려해야 하는 경우가 많지 않다면 간단한 잠금 쿼리를 이용해서 처리 할 수 있다. InnoDB의 잠금은 두가지로 나눌 수 있다. 하나는 LOCK IN SHARE MODE와 다른 하나는 FOR UPDATE다. 이 둘의 용도는 약간 다르기 때문에 자신의 용도에 따라 신중히 선택을 해야 한다.\nLOCK IN SHARE MODE는 SELECT를 한 후에 트랜잭션이 끝날 때까지 해당 ROW 값이 변경되지 않을 것을 보장한다. 바꿔 말하면 해당 ROW를 UPDATE 하거나 DELETE 하려는 쿼리는 잠김 상태가 되어 트랜잭션이 끝날 때까지 대기하게 된다. 하지만, SELECT는 얼마든지 여러 세션이 동시에 수행하는 것이 가능하다. 기존 SELECT 쿼리문 맨 뒤에 LOCK IN SHARE MODE 문장을 추가하는 것만으로 사용이 가능하지만, 트랜잭션이 끝나기 전까지만 유효하므로 auto_commit을 꺼야 한다.\n1 SELECT gold FROM players WHERE id = 1 LOCK IN SHARE MODE; FOR UPDATE는 SELECT로 가져 온 데이터를 변경을 하려고 할 때 사용한다.\n1 SELECT gold FROM players WHERE id = 1 FOR UPDATE; FOR UPDATE를 SELECT를 가져온 이후로 해당 ROW에 대해 다른 세션의 SELECT, UPDATE, DELETE 등의 쿼리가 모두 잠김 상태가 된다. 즉, FOR UPDATE를 한 세션 외에 다른 세션들은 모두 해당 ROW에 접근을 할 수 없게 되고, 모두 대기 상태가 된다. FOR UPDATE도 LOCK IN SHARE MODE처럼 트랜잭션이 끝나는 시점에서 풀린다. 예로 든 플레이어 간 골드 이전과 같은 경우에 알맞는 잠금이다.\n웹 프로그래밍에서는 쓰레드 프로그래밍처럼 세밀히 동시성을 고민 할 필요는 없지만, 웹이 기본적으로 다수 사용자가 동시에 같은 데이터에 접근을 하는 환경이므로 이로 인해 주의가 필요하다. 이 외에 이런 문제를 해결하기 위해 트리거나 저장 프로시저 등을 이용 할 수 있지만, 최근 웹서비스 초기에는 MySQL을 단순 key-value 저장소처럼 사용하다 추후 서비스 성장에 맞춰 noSQL을 도입하는 경우가 종종 보이므로, RDBMS의 기능을 너무 적극적으로 활용하지 않는 것이 낫지 않을까 싶다.\n","permalink":"https://sangheonhan.github.io/%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-mysql-%EC%9E%A0%EA%B8%88-%EB%91%90%EA%B0%80%EC%A7%80/","summary":"InnoDB를 사용하면서 동시성(Concurrency)을 고려하지 않고 개발을 하면 큰 문제가 생길 수 있다. 아래에 게임 속 플레이어 간 골드를 넘기는 간단한","title":"동시성 문제를 해결하기 위한 MySQL 잠금 두가지"},{"content":"PHP 언어에서 print 보다 echo가 빠르다는 것은 널리 알려진 사실이다. 이런 차이는 print의 경우 반환값이 존재하기 때문인데, 물론 이런 반환값 때문에 수식 내에서 사용 할 수 있다는 장점도 있다. 예를 들어 $result = ($n \u0026gt; 1) ? $n : print $n;처럼 쓸 수 있다.\n그럼 echo는 어떻게 사용해도 똑같을까? 그렇지는 않다. echo 또한 어떻게 사용하느냐에 따라 속도가 다르다.\n1 2 \u0026lt;?php echo \u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;\\n\u0026#34;; 1 2 \u0026lt;?php echo \u0026#34;1\u0026#34;.\u0026#34;2\u0026#34;.\u0026#34;3\u0026#34;.\u0026#34;\\n\u0026#34;; 이 두 코드는 완전히 동일한 결과를 출력하지만, 후자가 더 빠르고 바람직 하다.\n좀 더 자세히 이야기 하자면 첫번째 코드는 \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo;를 각각 출력한다. 정확히는 각 문장마다 write() 시스템 콜을 4번 호출한다.\n후자는 4개 문장을 하나로 합친 후에 write()를 1번 호출한다. 후자는 1번만 호출하기 때문에 시스템 콜에 대한 오버헤드가 1번만 발생하고, 커널 영역에 진입하는 횟수가 상대적으로 적다. 사용자 영역에서 커널 영역으로 진입하는 횟수가 많은 것이 좋지 않다. 직접 확인을 해보고 싶은 사람은 strace로 시스템 콜을 확인 해 보는 것도 추천한다.\n그럼 도트(concatenation) 연산자를 사용하는 것이 최선의 방법일까? 엄밀히 말하면 모든 경우에 그렇지는 않다.\n1 2 3 4 5 6 \u0026lt;?php $a = 1; $b = 2; $c = 3; echo $a.$b.$c.\u0026#34;\\n\u0026#34;; 1 2 3 4 5 \u0026lt;?php $a = 1; $b = 2; $c = 3; echo \u0026#34;{$a}{$b}{$c}\\n\u0026#34;; 이 두 코드를 비교하면 전자 보다 후자가 빠르다. 그 이유는 도트 연산자가 두 번 이상 등장하면 연산 작업을 중복하여 여러번 수행하는 문제가 있기 때문이다. 도트를 사용하는 횟수에 따라 급격히 연산 작업 횟수가 증가하므로 다수의 변수를 합친다면 비효율적인 된다.\n그러므로 두 번 이상 도트를 사용하여 문자열을 출력해야 하는 경우 중괄호를 사용해서 문자열 내에서 처리를 하는 것이 빠르다. 이 문제는 합치기 연산 횟수에 관련된 것이므로 꼭 echo 문이 아니라 변수에 대입하는 경우도 동일하다.\n지금까지 도트 연산자를 주로 사용했다면 앞으로는 중괄호를 사용하는 습관을 들여보도록 하자.\n","permalink":"https://sangheonhan.github.io/%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-echo%EB%A5%BC-%EC%9C%84%ED%95%98%EC%97%AC/","summary":"PHP 언어에서 print 보다 echo가 빠르다는 것은 널리 알려진 사실이다. 이런 차이는 print의 경우 반환값이 존재하기 때문인데, 물론 이런 반환값 때문에 수식 내에서","title":"보다 빠른 echo를 위하여"},{"content":"매직메소드 __get, __set에 대해서는 크게 두가지 의견이 있는데, 하나는 OO를 해치기 때문에 getter, setter를 정의해서 사용하라는 것이고, 또다른 하나는 스크립트 언어의 특성이므로 적극 활용을 해야 한다는 것이다.\n한동안 getter, setter를 정의해서 사용하다, PHP가 스크립트 언어라는 특성을 활용하는 것이 맞는 이야기인 것 같아 매직메소드를 쓰기 시작한 것이 얼마 전부터 사용하고 있다.\n그러나 매직메소드는 getter, setter를 작성하는 수고스러움 이상으로 문제를 일으키고 있다. 앞으로 __get(), __set() 매직메소드는 특별한 일이 아닌 이상 사용하지 않을 것 같다.\n일단 아래 소스 코드를 보자. 전에 올렸던 글의 예제다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public function __get($name) { if ( property_exists($this, $name) ) { return $this-\u0026gt;{$name}; } $method_name = \u0026#34;get_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { return $this-\u0026gt;{$method_name}(); } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } public function __set($name, $value) { if ( property_exists($this, $name) ) { $this-\u0026gt;{$name} = $value; return; } $method_name = \u0026#34;set_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { $this-\u0026gt;{$method_name}($value); return; } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } 이 코드는 하나의 클래스에서 문제를 일으키지 않는다. 그러나 상속을 받은 경우 다르다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;?php class Foobar { private $name; public function __get($name) { if ( property_exists($this, $name) ) { return $this-\u0026gt;{$name}; } $method_name = \u0026#34;get_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { return $this-\u0026gt;{$method_name}(); } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } public function __set($name, $value) { if ( property_exists($this, $name) ) { $this-\u0026gt;{$name} = $value; return; } $method_name = \u0026#34;set_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { $this-\u0026gt;{$method_name}($value); return; } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } } class MyFoobar extends Foobar { private $age; } $foobar = new Foobar(); $foobar-\u0026gt;name = \u0026#34;Foobar\u0026#34;; echo \u0026#34;{$foobar-\u0026gt;name}\\n\u0026#34;; $my_foobar = new MyFoobar(); $my_foobar-\u0026gt;age = 42; $my_foobar-\u0026gt;name = \u0026#34;My Foobar\u0026#34;; echo \u0026#34;{$my_foobar-\u0026gt;name}\\n\u0026#34;; echo \u0026#34;{$my_foobar-\u0026gt;age}\\n\u0026#34;; ?\u0026gt; 실행을 시켜보면 __get() 메소드에서 \u0026lsquo;MyFoobar\u0026rsquo; 클래스 멤버 변수 \u0026lsquo;$age\u0026rsquo;를 찾지 못 하는 것을 에러 메시지로 확인 할 수 있다. 이렇게 된 것은 __get() 메소드가 \u0026lsquo;Foobar\u0026rsquo; 클래스 내에 존재하기 때문이다. 이를 해결하기 위해서는 __get(), __set() 메소드를 \u0026lsquo;MyFoobar\u0026rsquo;로 옮기면 되지만, 그런 경우 \u0026lsquo;Foobar\u0026rsquo; 클래스에 문제가 생길뿐더라 전혀 아름다운 모습이 아니기도 하다.\n그나마 조금 절충을 해 볼 수 있는 방법이 멤버 변수들은 \u0026lsquo;protected\u0026rsquo;로 바꾸고 \u0026lsquo;ReflectionProperty()\u0026rsquo; 함수를 이용하는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;?php class Foobar { protected $name; public function __get($name) { if ( property_exists($this, $name) ) { $refprop = new ReflectionProperty($this, $name); $refprop-\u0026gt;setAccessible($name); return $refprop-\u0026gt;getValue($this); } $method_name = \u0026#34;get_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { return $this-\u0026gt;{$method_name}(); } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } public function __set($name, $value) { if ( property_exists($this, $name) ) { $refprop = new ReflectionProperty($this, $name); $refprop-\u0026gt;setAccessible($name); $refprop-\u0026gt;setValue($this, $value); return; } $method_name = \u0026#34;set_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { $this-\u0026gt;{$method_name}($value); return; } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } } class MyFoobar extends Foobar { protected $age; } $foobar = new Foobar(); $foobar-\u0026gt;name = \u0026#34;Foobar\u0026#34;; echo \u0026#34;{$foobar-\u0026gt;name}\\n\u0026#34;; $my_foobar = new MyFoobar(); $my_foobar-\u0026gt;age = 42; $my_foobar-\u0026gt;name = \u0026#34;My Foobar\u0026#34;; echo \u0026#34;{$my_foobar-\u0026gt;name}\\n\u0026#34;; echo \u0026#34;{$my_foobar-\u0026gt;age}\\n\u0026#34;; ?\u0026gt; 에러가 발생하지 않고 의도한대로 동작한다. 하지만 private으로 선언한 멤버 변수들을 protected로 선언해야 하는 문제가 있다. 이런 문제를 완전히 해결하기 위해서는 다른 언어들처럼 getter, setter를 제대로 정의하는 것이 나아 보인다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?php class Foobar { private $name; public function name() { return $this-\u0026gt;name; } public function set_name($name) { $this-\u0026gt;name = $name; } } class MyFoobar extends Foobar { private $age; public function age() { return $this-\u0026gt;age; } public function set_age($age) { $this-\u0026gt;age = $age; } } $foobar = new Foobar(); $foobar-\u0026gt;set_name(\u0026#34;Foobar\u0026#34;); echo \u0026#34;{$foobar-\u0026gt;name()}\\n\u0026#34;; $my_foobar = new MyFoobar(); $my_foobar-\u0026gt;set_age(42); $my_foobar-\u0026gt;set_name(\u0026#34;My Foobar\u0026#34;); echo \u0026#34;{$my_foobar-\u0026gt;name()}\\n\u0026#34;; echo \u0026#34;{$my_foobar-\u0026gt;age()}\\n\u0026#34;; ?\u0026gt; 처음 의도한대로 멤버 함수를 private으로 유지하면서 자식 클래스에서 부모의 멤버 변수를 접근하는데 아무런 문제가 생기지 않는다.\n다만 멤버 변수가 많은 경우 일일히 getter, setter를 입력하는 것이 번거로우므로 snippet을 생성하는 스크립트나 에디터의 snippet 생성 기능을 적극적으로 활용해서 반복적인 작업 시간을 절약하는 것이 좋을 듯 하다. 간단한 클래스 코드를 생성 해주는 페이지도 있으니 이것을 사용해도 괜찮다.\n","permalink":"https://sangheonhan.github.io/php-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%A4%EC%A7%81%EB%A9%94%EC%86%8C%EB%93%9C-__get-__set-%EB%AC%B8%EC%A0%9C/","summary":"매직메소드 __get, __set에 대해서는 크게 두가지 의견이 있는데, 하나는 OO를 해치기 때문에 getter, setter를 정의해서 사용하라는 것이고, 또다른 하나는 스크립","title":"PHP: 클래스 매직메소드 __get(), __set() 문제"},{"content":"PHP는 웹에 특화된 언어다. 그렇게 때문에 애플리케이션이나 시스템 프로그래밍을 할 때 필요한 기능이 부족하다. 하지만 서비스를 만들다 보면 서버(데몬)처럼 웹을 벗어난 것이 필요 할 때가 생긴다. 이럴 때는 아파치(Apache)나 crond를 이용해 문제를 해결 할 수 있다. 그러나 아파치나 crond를 이용한 방법은 어느 정도 한계가 있기 때문에 경우에 따라 해결책이 되지는 못 한다. 이런 경우 백그라운드로 동작하는 데몬을 만드는 것이 깔끔하다. 데몬을 만드는 방법은 널리 알려져있기 때문에 거기에 맞춰 코드를 작성해도 되지만, 굳이 바퀴를 다시 발명 할 필요는 없을테니 System_Daemon PEAR 모듈을 이용하면 된다. System_Daemon 모듈을 사용한 간단한 예제를 우선 살펴보자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/local/php/bin/php -q \u0026lt;?php ini_set(\u0026#39;include_path\u0026#39;, ini_get(\u0026#39;include_path\u0026#39;).\u0026#39;:..\u0026#39;); error_reporting(E_ALL); require_once \u0026#34;System/Daemon.php\u0026#34;; $appname = \u0026#34;example\u0026#34;; System_Daemon::setOption(\u0026#34;appName\u0026#34;, $appname); System_Daemon::setOption(\u0026#34;appRunAsUID\u0026#34;, getmyuid()); System_Daemon::setOption(\u0026#34;appRunAsGID\u0026#34;, getmygid()); System_Daemon::setOption(\u0026#34;logLocation\u0026#34;, getcwd().\u0026#34;/log/$appname.log\u0026#34;); System_Daemon::setOption(\u0026#34;appPidLocation\u0026#34;, getcwd().\u0026#34;/log/$appname/$appname.pid\u0026#34;); System_Daemon::start(); while ( true ) { System_Daemon::log(System_Daemon::LOG_INFO, \u0026#34;HELLO - \u0026#34;.time()); sleep(1); } System_Daemon::stop(); ?\u0026gt; 참고로 System_Daemon 모듈을 사용하기 위해서는 --enable-pcntl 옵션으로 컴파일 되어 있어야 한다. 1번째 줄의 php 경로는 각자 php 설정에 맞춰 수정하면 된다. System_Daemon 사용법은 간단하나 몇가지 조심해야 할 부분이 있다. appRunAsUID나 appRunAsGID를 통해 특정 사용자나 그룹으로 실행하고 싶은 경우 root 권한이 필요하다.\n또한 pid 파일은 다른 파일과 섞이지 않는 독립적인 디렉토리로 설정해야 하며, 자동으로 디렉토리를 생성해주지 않는다. 보통 로그 디렉토리 안에 log/foobar/foobar.pid 형식으로 구성한다고 보면 된다. 만약 root로 실행을 하거나 디렉토리 퍼미션을 잘 조정 해 줄 생각이라면 /var/run 안으로 구성하는 것이 더 좋겠다.\n그리고 logLocation이나 appPidLocation 설정은 절대 경로로 해야 한다. 보통 프로세스가 데몬으로 바뀌면 워킹 디렉토리를 루트(/)로 설정을 하게 되는데, 이것에 영향을 받기 때문으로 보인다.\nPEAR 사이트의 문서에는 옵션이 없으므로 어떤 옵션이 있는지 직접 소스 코드를 열어 읽어 봐두어야 한다. lib/php/System/Daemon.php 파일이다. php를 패키지로 설치한 경우 깊숙히 들어있으므로 locate 명령으로 찾는 것이 더 편하다. 전체 코드를 다 볼 필요는 없고 $_optionDefinitions 변수만 읽어 보면 된다.\n","permalink":"https://sangheonhan.github.io/php%EB%A1%9C-%EC%84%9C%EB%B2%84%EB%8D%B0%EB%AA%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0/","summary":"PHP는 웹에 특화된 언어다. 그렇게 때문에 애플리케이션이나 시스템 프로그래밍을 할 때 필요한 기능이 부족하다. 하지만 서비스를 만들다 보면 서버(데몬)처럼 웹","title":"PHP로 서버(데몬) 만들기"},{"content":"멀티 프로세스끼리는 멀티쓰레드처럼 직접 변수에 접근하기 어렵기 때문에 공유 메모리 등과 같은 IPC를 이용해서 데이터를 주고 받는데, 복잡하고 다양한 기능이 필요없다면 메모리맵을 통해 서로 간단히 데이터를 공유 할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; int main(void) { void *p; p = mmap(0, 1024, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); if ( p == MAP_FAILED ) { puts(\u0026#34;mmap() error\u0026#34;); exit(1); } sleep(10); if ( munmap(p, 1024) ) { puts(\u0026#34;munmap() error\u0026#34;); exit(1); } return 0; } ","permalink":"https://sangheonhan.github.io/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%81%BC%EB%A6%AC-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0-%EB%B0%A9%EB%B2%95-mmap/","summary":"멀티 프로세스끼리는 멀티쓰레드처럼 직접 변수에 접근하기 어렵기 때문에 공유 메모리 등과 같은 IPC를 이용해서 데이터를 주고 받는데, 복잡하고 다양한 기능이 필요","title":"멀티 프로세스끼리 간단한 데이터 공유 방법 – mmap()"},{"content":"pthread를 사용하는 멀티쓰레드 데몬이라면 pthread_mutex_lock()을 사용해 잠금을 할 것이며, 멀티프로세스 데몬이라면 세마포어를 사용 할 것이다.\n흥미로운 부분은 많은 OS에서 뮤텍스를 이진 세마포어(binary semaphore)로 구현을 하고 있고, pthread 또한 멀티프로세스를 위한 잠금을 지원한다는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(void) { pthread_mutex_t lock; pthread_mutexattr_t attr; if ( pthread_mutexattr_init(\u0026amp;attr) ) { puts(\u0026#34;pthread_mutexattr_init() error\u0026#34;); exit(1); } if ( pthread_mutexattr_setpshared(\u0026amp;attr, PTHREAD_PROCESS_SHARED) ) { puts(\u0026#34;pthread_mutexattr_setpshared() error\u0026#34;); exit(1); } if ( pthread_mutex_init(\u0026amp;lock, \u0026amp;attr) ) { puts(\u0026#34;pthread_mutex_init() error\u0026#34;); exit(1); } int i; for ( i = 0; i \u0026lt; 5; i++ ) { if ( fork() == 0 ) { int j; for ( j = 0; j \u0026lt; 5; j ++ ) { if ( pthread_mutex_lock(\u0026amp;lock) ) { puts(\u0026#34;pthread_mutex_lock() error\u0026#34;); exit(1); } printf(\u0026#34;pid = %d, lock\\n\u0026#34;, getpid()); sleep(1); if ( pthread_mutex_unlock(\u0026amp;lock) ) { puts(\u0026#34;pthread_mutex_unlock() error\u0026#34;); exit(1); } printf(\u0026#34;pid = %d, unlock\\n\u0026#34;, getpid()); } break; } else { wait(NULL); } } pthread_mutexattr_destroy(\u0026amp;attr); pthread_mutex_destroy(\u0026amp;lock); return 0; } 멀티프로세스에서 pthread_mutex_lock()으로 잠금을 하기 위해서는 17번째 줄처럼 pthread 뮤텍스를 설정 해주어야 한다. 이 설정은 fork()가 호출되기 전에 이뤄져야 한다는 점을 주의하자.\n","permalink":"https://sangheonhan.github.io/%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8D%B0%EB%AA%AC%EC%97%90%EC%84%9C-%EB%9D%BD%ED%82%B9locking%ED%95%98%EA%B8%B0/","summary":"pthread를 사용하는 멀티쓰레드 데몬이라면 pthread_mutex_lock()을 사용해 잠금을 할 것이며, 멀티프로세스 데몬이라면 세마포어를","title":"멀티프로세스 데몬에서 락킹(Locking)하기"},{"content":"개발자들이 지리좌표계 내지는 지리정보를 다뤄야 할 일이 점점 많아지고 있습니다. 특히 모바일처럼 위치 정보를 손쉽게 얻을 수 있는 장비가 널리 보급이 되면서 웬만한 앱은 대부분 위치(지리좌표)를 활용하고 있는 상황입니다.\n불행하게도 지리좌표는 여러 종류이고 시스템마다 서로 다른 경우가 많습니다. 이런 경우 알맞는 지리 좌표로 변환을 해줘야 하는데 지리학을 전공하지 않은 개발자로서는 쉽지 않은 일입니다. 그런 이유로 이런 일을 대신 해줄 라이브러리를 찾게 되는데, 제가 찾은 것은 PROJ.4 입니다.\nPHP에서 사용 할 수 있는 유사한 proj4php도 있지만, 업데이트 속도나 신뢰성 부분에서 PROJ.4 보다 떨어지는 느낌입니다. 하지만 PROJ.4는 PHP 바인드가 없습니다. 하지만 다행히 MapServer 프로젝트에서 PROJ.4를 이용한 PHP 바인드를 제공합니다.\n여기서는 MapServer를 이용해서 PROJ.4를 PHP에서 사용하는 방법을 CentOS 5를 기준으로 설명 하겠습니다. 다른 배포판이나 OS에서는 공식 사이트의 문서를 참고하여 적절히 옵션을 변경하시기 바랍니다.\n우선 PROJ.4를 설치 합니다.\n1 2 3 4 5 6 wget http://download.osgeo.org/proj/proj-4.8.0.tar.gz tar -xvzf proj-4.8.0.tar.gz cd proj-4.8.0 ./configure --prefix=/usr/local/proj-4.8.0 make sudo make install make 할 때 -j 옵션을 사용하니 컴파일 오류가 생겼습니다.\n이제 MapServer를 설치 할 차례입니다.\n1 2 3 4 5 6 7 8 wget http://download.osgeo.org/mapserver/mapserver-6.0.3.tar.gz tar -xvzf mapserver-6.0.3.tar.gz cd mapserver-6.0.3 ./configure --with-proj=/usr/local/proj-4.8.0 --with-php=/usr/include/php make cd mapscript/php cp php_mapscript.so /usr/lib64/php/modules/ vi /etc/php.d/php_mapscript.ini 1 cat /etc/php.d/php_mapscript.ini 1 extension=php_mapscript.so 만약 PHP 5.2 미만을 사용하신다면 MapServer 5.6 버전을 받으시면 됩니다.\n1 2 3 wget http://download.osgeo.org/mapserver/mapserver-5.6.8.tar.gz tar -xvzf mapserver-5.6.8.tar.gz cd mapserver-5.6.8 PHP 모듈에 MapScript가 설치된 것을 확인합니다.\n1 php -m | grep MapScript 이제 지리좌표를 변환 해 보도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $projInObj = ms_newprojectionobj(\u0026#34;proj=latlong,datum=WGS84,ellps=WGS84\u0026#34;); $projOutObj = ms_newprojectionobj(\u0026#34;proj=tmerc,lat_0=38N,lon_0=127.5E,ellps=WGS84,x_0=1000000,y_0=2000000,k=0.9996\u0026#34;); $poPoint = ms_newpointobj(); $poPoint-\u0026gt;setXY(127.034612, 37.509385); $poPoint-\u0026gt;project($projInObj, $projOutObj); print(\u0026#34;{$poPoint-\u0026gt;x}, {$poPoint-\u0026gt;y}\\n\u0026#34;); ?\u0026gt; 1 php projection.php WGS84 경위도 좌표계의 값이 UTM-K 좌표계 값으로 잘 바뀌는 것을 확인 할 수 있습니다. 각 지리좌표계별 Proj.4 인자값은 주요 좌표계 EPSG코드 및 proj4 인자 정리를 참고 하시기 바랍니다.\n지리좌표계에 대해서 개발자로서 기본적인 내용을 빠르게 이해하고 싶으시다면 KTH 개발자 블로그에 올라온 LBS 개발을 위한 지도의 타원체 및 투영법 기초 가이드가 도움이 되실 겁니다.\n보다 자세한 사용법은 PHP MapScript 설명서를 참고 하시면 됩니다.\n","permalink":"https://sangheonhan.github.io/php%EB%A1%9C-%EC%A7%80%EB%A6%AC%EC%A2%8C%ED%91%9C%EA%B3%84-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/","summary":"개발자들이 지리좌표계 내지는 지리정보를 다뤄야 할 일이 점점 많아지고 있습니다. 특히 모바일처럼 위치 정보를 손쉽게 얻을 수 있는 장비가 널리 보급이 되면서 웬만한 앱","title":"PHP로 지리좌표계 변환하기"},{"content":"PHP에는 __get(), __set()이란 특별한 매직메소드가 있습니다. 이 매직메소드의 사용에 대해서 여러 논란이 있기는 하지만, 개인적으로 적절히 사용을 한다면 매우 유용하다고 생각합니다. 매직 메소드를 구현하는 방법은 여러가지이지만 그 중 간단하면서도 유용한 코드 하나를 소개 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public function __get($name) { if ( property_exists($this, $name) ) { return $this-\u0026gt;{$name}; } $method_name = \u0026#34;get_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { return $this-\u0026gt;{$method_name}(); } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } public function __set($name, $value) { if ( property_exists($this, $name) ) { $this-\u0026gt;{$name} = $value; return; } $method_name = \u0026#34;set_{$name}\u0026#34;; if ( method_exists($this, $method_name) ) { $this-\u0026gt;{$method_name}($value); return; } trigger_error(\u0026#34;Undefined property $name or method $method_name\u0026#34;); } 보여드린 코드는 이름이 맞는 변수가 있으면 그것을 get 또는 set 하고, 만약 변수가 없지만 get_foobar(), set_foobar()와 같은 메소드가 있으면 그것을 호출하는 방식입니다.\n특별한 기능이 필요하지 않다면 위 메소드를 클래스에 넣어두는 것만으로 기본적인 프로퍼티에 대한 get, set 메소드의 구현은 끝나게 됩니다.\n만약 프로퍼티 보다 get_foobar(), set_foobar()에 우선을 두어 동작시키고 싶다면 매직메소드 내에서 프로퍼티를 찾는 부분과 메소드를 찾는 부분의 if 문 위치를 서로 바꾸어 주면 됩니다. 이렇게 할 결우 특정한 메소드의 get, set 동작만 특별하게 변형시키고 싶을 때 유용합니다.\n","permalink":"https://sangheonhan.github.io/php-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%A4%EC%A7%81%EB%A9%94%EC%86%8C%EB%93%9C-__get-__set-%EC%98%88%EC%A0%9C/","summary":"PHP에는 __get(), __set()이란 특별한 매직메소드가 있습니다. 이 매직메소드의 사용에 대해서 여러 논란이 있기는 하지만, 개인적으로 적절히 사용을 한다면 매우","title":"PHP 클래스 매직메소드 __get(), __set() 예제"},{"content":"이슈 트래커(Issue Tracker)인 트랙(Trac)을 어떻게 사내에 도입하게 됐고 그것으로 인한 효과와 구성원들에 대한 반응을 기록한 것입니다.\n트위터에서 김기웅(@KayKimTwit)님이 질문을 하셨는데 그에 대한 답변으로서 글을 쓰게 됐습니다. 하지만 이슈 트래커를 도입하려고 하는 다른 분들에게도 참고가 되었으면 합니다. 참고로 트랙 도입하던 당시 회사 구성원은 약 20명이 조금 넘었고, 약 30명이 조금 넘는 인원까지 사용하였습니다.\n트랙(Trac)을 선택하다 트랙의 도입은 형상관리도구인 서브버전(Subversion)의 성공적인 사내 정착 이후 새로운 시스템을 통해 효율 증대를 희망했던 저의 주장에 따라 시작됐습니다.\n여러가지 중 트랙이 선정된 것은 비교적 다른 도구보다 예쁜 디자인이 컸습니다. 디자인이 예쁘면 개발자가 아닌 사람들도 거부감이 덜하기 때문입니다.\nnFORGE도 검토되었습니다. 한국어가 잘 지원되고 PHP를 사용했으며 일정 등 개발자 외의 사람들에게도 유용한 기능이 많다고 판단했습니다. 하지만 국내 오픈소스의 꾸준한 지원에 대해 의구심을 가질 수 밖에 없어 트랙으로 정했습니다. 참고로 nFORGE는 지금까지도 잘 발전되고 있으며, 지금은 도입을 해도 괜찮을 정도라고 생각합니다.\n도입의 어려움 트랙 도입을 주장한 초기에는 역시 기술자들 외 사람들의 부정적인 반응이 많았습니다.\n부정적 반응들은 주로 아래와 같은 것들입니다.\n기존 업무에 절차만 늘어나서 오히려 방해가 될 것 같아요. 기술적인 입력 항목들이 많아 이해하기 힘들어요. 몇번 써보다 안 쓰게 되는 것 아닐까요? 이런 반응으로 인해 거의 1년에 걸쳐 몇차례 도입에 대해서 이야기를 나누었으나 도입을 하지는 못 했습니다.\n첫 도입 시도 이후 거의 1년 후에야 경영진의 재가와 부서장의 의지로 일괄 도입을 결정하게 됐습니다. 트랙을 테터앤컴퍼니에서 잘 쓰고 있다는 것이 어느 정도 영향이 있었던 것으로 보입니다. 레퍼런스의 중요성이 여기서도 나타나는 것 같습니다. 뭔가 새로운 도구의 도입이 잘 안 될 경우 같은 시장의 유명 업체에서 사용 중이라는 논리가 비교적 잘 먹히는듯 합니다.\n트랙을 시작하다 일단 첫 도입은 개발 관련 부서만 하게 되었습니다. 여기에는 디자인과 운영, 마케팅 부서가 간접적으로 연결이 되어 있습니다.\n우선 모든 서브버전 저장소를 트랙에 연결시키고, 우리가 개발하는 프로젝트들을 등록하였습니다.\n초기에는 단순하게 티켓(버그, 이슈, 작업)을 발행하고 처리하는 방식으로 사용하기 시작했습니다. 기획, 디자인, 운영, 마케팅에서 개발이 필요한 것이 있으면 디자인이나 개발부서로 티켓을 발행을 하도록 요청을 드렸습니다. 잘 안 될 경우 직접 개발자가 도와주어 티켓을 발행했습니다. 티켓은 상황에 따라 다시 다른 사람이나 부서로 이관되었고, 경우에 따라서는 취소(Invalid 또는 Works for me) 했습니다.\n차츰 시간이 흐르자 개발 외에 트랙의 활용 범위가 늘어나게 되었습니다.\n스크럼과의 연계 개발을 위해 스크럼을 도입하였을 때 트랙의 마일스톤과 연계하였습니다.\n스프린트가 시작되면 하나의 스프린트를 트랙의 마일스톤으로 등록했습니다. 그리고 스프린트 백로그를 마일스톤의 티켓으로 등록했습니다.\n물론 스크럼 미팅 때는 포스트잇을 사용했습니다. 다만 코드 변경에 대한 이력과 전사적인 진척 공유를 위해 트랙에도 티켓을 만들도록 했습니다.\n스크럼을 사용하지 않고 기존 방식으로 개발 할 때도 역시 기획에 따라 마일스톤과 함께 작업(Task)들을 등록하여 개발하였는데 이것에는 디자인 작업도 포함됩니다.\n운영파트의 캠페인 관리 캠페인은 보통 고정적으로 처리되는 패턴과 구체적인 담당자가 있습니다. 이것을 하나의 티켓으로 처리하여 댓글이나 상태로서 캠페인의 진행과 과정을 기록으로 남기도록 하였습니다. 여기에 사용자 정의 쿼리를 통해서 담당자별로 처리 중인 캠페인을 보거나, 진행 과정별로 캠페인들을 그룹핑 하여 볼 수 있도록 했습니다.\n사용자 정의 쿼리와 커스텀 필드를 사용하면 트랙을 활용해서 업무에 유용한 기능을 손쉽게 만드는 것이 가능합니다.\n기획, 디자인, 개발, 운영의 전통적인 개발 프로세스 폭포수 모델의 전통적인 방식과 유사한 개발 프로세스도 많이 사용했습니다. 이 과정에서 트랙을 아래처럼 활용했습니다.\n기획자가 스토리보드 작성합니다. 일정 회의 후 트랙에 마일스톤을 등록합니다. 개발자들은 모듈 개발 등의 일들을 티켓으로 만들어 마일스톤에 등록합니다. 기획자와 디자이너는 협의하여 디자인 티켓을 만들어 마일스톤에 등록합니다. 디자이너들이 디자인을 하고 티켓을 통해 기획자 및 개발자들과 의견 교환을 합니다. 디자이너들이 티켓에 디자인 파일을 첨부하거나 댓글을 달면 관련자들에게 자동으로 메일로서 공유가 됩니다. 기획자와 디자이너의 작업이 마무리 되면 개발자에게 해당 티켓이 넘어옵니다. 개발자들은 개발 후 티켓 완료합니다. 기획자와 디자이너의 일차적인 QA 후 티켓이 되살아나거나 추가되기도 합니다. 최종적인 테스트가 QA를 담당하는 운영부서로 넘어갑니다. 버그나 수정 사항이 발견되면 티켓이 마일스톤에 추가합니다. 서비스가 런칭되면서 마일스톤의 모든 티켓은 처리됨 상태로 되면 진행율이 100%로 표시됩니다. 다음 마일스톤 전에라도 긴급히 수정해야 할 사항이 발생하면 현재 마일스톤에 티켓을 추가적으로 발행하여 처리합니다. 마케팅 부서의 요청 마케터나 AE가 서비스 상의 변화나 개발이 필요한 사항이 있으면 티켓을 발급합니다. 이 때 티켓은 현재 진행 중인 프로젝트에서 수정이 필요한 사항은 해당 프로젝트로 보내고, 그 외의 것들은 별도의 전사적인 작업을 관리하기 위한 프로젝트로 보냅니다. 관리자들은 일정, 인력을 고려하여 해당 하는 티켓을 적절한 담당자에게 할당(Assign) 합니다. 담당자는 해당 티켓에 대해 처리를 합니다. 처리 전에 댓글을 통해서 티켓을 발행한 사람과 의견을 교환하기도 하고 경우에 따라서 개발하지 않고 티켓을 닫아버리기도 합니다.\n이 부분에서 여러 프로젝트가 있는 경우 어느 프로젝트로 티켓을 보내야 하는지를 이해시키는 것이 어려웠습니다. 특히 트랙은 프로젝트 별로 좀 나뉘어지는 모양새로 이런 이해가 더욱 어려웠던 것 같습니다.\n트랙 도입 후 사람들의 변화 처음에는 사용에 어려움을 호소하거나 강하게 거부하던 사람들도 사용한지 1년이 넘어가자 반대로 업무 진행을 트랙에 전적으로 의존하는 경향이 나타났습니다. 트랙에 자신과 관련된 일이 등록이 되면 이에 대해 안내 메일이 발송되는데, 다들 이 메일에 깊히 의존하게 됐습니다. 아침에 출근하여 온 메일을 확인하고, 구체적인 티켓 내용을 파악한 후 그에 따라 피드백을 보내고, 티켓을 처리한 후에 닫는 흐름이 자연스럽게 회사 내에 정착되었습니다.\n한번은 구글이 트랙에서 발신하는 메일을 스팸으로 처리하여 블럭하는 바람에 트랙으로부터 메일이 제대로 송신되지 않은 적이 있었는데 이 때 사람들은 업무가 진행이 안 된다며 계속 문제 해결을 제게 요청하였습니다. 이것이 트랙 도입 1년만에 일어난 일입니다.\n트랙 도입 후 잇점 회의 중에 좋은 의견이 나와서 그렇게 처리하자고 합의를 보았는데 몇 달이 지나도 그 일이 처리되지 않고 있다 사람들 뇌리에서 잊혀지는 일이 있습니다. 그러나 트랙을 도입한 이후로 이런 일은 생기지 않았습니다. 일정상 우선 순위에 밀려서 몇 달씩 티켓이 처리되지 못하는 일은 있었지만, 트랙에 티켓이 계속 남아있기 때문에 일이 완전히 잊혀져 사라지는 일이 없었습니다. 더구나 티켓에는 담당자도 할당되어 있기 때문에 일 처리가 안 될 경우 해당 담당자에게 물어보거나 왜 지연되는지에 대한 답변을 확실히 얻을 수 있었습니다.\n시간이 흘러 해당 티켓이 무의미 해지거나, 우선순위에 밀려 결국 티켓을 취소하더라도 티켓을 처음 만든 사람에게 메일로 안내가 날아갑니다. 즉, 몇 달 뒤에라도 그 일이 어떻게 됐는지에 대한 피드백을 받지 못 하는 일은 생기지 않았습니다. 자신이 발행한 티켓이 처리되지 않고 닫혀버리더라도 티켓을 다시 열어 할당하는 것이 가능하므로 얼마든지 티켓에 대한 처리를 재차 요청하는 것이 가능하여 티켓의 생명에 대해 일일히 신경쓰지 않아도 되는 잇점이 있었습니다.\n그리고 어떤 작업이 왜 시작됐는지 알 수 있다는 것이 트랙의 큰 잇점 중 하나였습니다.\n하나의 시나리오를 가지고 이야기 해 보려고 합니다. 개발자가 코드를 보다 별 의미없어 보이는 코드를 발견했습니다. 1년 전에 6개월 계약으로 외부 업체와 연동하기 위해 추가한 코드였습니다. 그래서 개발자는 이제 별로 필요없겠다고 생각하고 삭제를 했습니다. 몇 시간 후 마케팅 부서에서 외부 업체에서 연락왔는데 갑자기 우리와 연동한 부분이 동작하지 않는다고 합니다. 마케팅 부서에 알아보니 계약을 끝났지만 서로 협력하기로 구두로 약속하고 1년 정도 더 유지하기로 한 것이라고 합니다.\n이처럼 형상관리도구는 개발자로서 왜 변화한지 기록은 되어도, 회사 전체적으로 보았을 때의 기록으로는 부족한 면이 있습니다. 이렇게 트랙을 쓰면 최초로 그 일을 만들어낸 담당자에게 손쉽게 확인 할 수 있습니다. 댓글 하나만 달면 됩니다. \u0026ldquo;이 코드를 지울까 하는데 그 업체랑 계약 끝나지 않았어요?\u0026rdquo;\n이런 기록은 트랙에 남아 다른 개발자가 그 코드에 대해서 의문을 갖게 되었을 때도 손쉽게 1년 정도 더 유지해야 하는 코드라는 것을 알 수 있게 됩니다. 다른 사람들의 집중을 방해하거나 시간을 빼았지 않고 말입니다.\n이슈 트래커 도입시 신경을 써야 할 점 이슈 트래커의 개념이나 처리 절차, 항목의 의미 등은 개발자들에게는 어느 정도 익숙할지 몰라도 디자이너나 마케터, 운영자들에게는 쉽지 않은 개념일 수 있습니다. 그렇기에 세미나나 자료 등을 통해서 이슈 트래커 전반에 대한 충분한 설명과 강의가 필요합니다.\n위에서도 언급했지만 디자인이 예쁜 이슈 트래커를 도입해야 합니다. 심리적으로 디자인이 예쁘면 보다 쓰기 쉽다라고 느낀다고 합니다. 그렇기에 이슈 트래커 중에 디자인이 예쁜 것을 도입하고, 가능하면 회사의 컨셉에 맞도록 독자적인 스킨을 입히는 수고 정도는 해주는 것이 좋습니다.\n이메일을 통한 안내가 반드시 포함되어야 합니다. 레드마인과 같은 것은 한 페이지를 통해서 모든 프로젝트의 일감을 확인 할 수 있지만, 트랙은 그런 기능이 없습니다. 설사 그런 기능이 있다고 하더라도 메일과 이슈 트래커를 둘 다 살펴보고 있어야 한다면 업무에 일이 하나 더 늘었다고만 느낄 수 있습니다. 거기에 익숙하지 않은 이슈 트래커를 자주 확인도 하지 않을 것이고, 그렇다 보면 티켓을 만든 사람은 일 처리가 늦게 된다고 느껴져 점점 티켓을 발행하지 않을 수 있습니다. 티켓이 처리가 되던 안 되던 티켓을 통한 피드백이 빠르고 원활해야 많은 사람들이 점차 활용도를 높여가게 됩니다. 그러므로 무조건 모든 티켓의 발행, 처리 등은 메일을 통해서 실시간으로 관련자들에게 안내가 되어야 합니다.\n일정 부분은 마일스톤의 마감일(Due date) 정도면 충분한 것 같습니다. 레드마인의 경우 간트 차트를 지원하고, nFORGE도 달력 형식의 일정 관리를 지원하기는 하나, 애자일 방법론을 쓰던 안 쓰던 마일스톤의 기간은 짧은 것이 좋고, 보통 2-3주 간격의 마일스톤이라면 각 티켓에 대한 세세한 일정 관리 보다는 마일스톤 단위의 일정 관리만 있으면 충분하다고 생각 됩니다.\n가능하면 많이 쓰는 이슈 트래커가 좋은 듯 합니다. 이는 향후 꾸준한 지원이나 관련 플러그인 및 자료의 존재 때문이기도 하지만 더 중요한 것은 레퍼런스가 존재하는가 여부입니다. 많이 쓰는 이슈 트래커는 동종 업계에서 주목받는 업체에서도 사용하고 있을 가능성이 높고, 이를 통해서 부정적인 사람들에게도 받아들여질 기회를 만들 수 있습니다.\n아직 이슈 트래커를 도입하지 못한 분들께 트랙을 사내에 도입한지 2년 8개월여가 지났고, 올해 초부터는 레드마인(Redmine)도 도입하였습니다. 프로젝트별로 설치하고 통합적인 관리가 지원되지 않았던 트랙에 비해, 해당 기능들이 지원되기 때문에 도입을 한 것인데 향후에 레드마인으로 완전히 이전하게 되지 않을까 합니다. 레드마인을 도입하게 된데에는 형상관리도구로 Git을 도입한 것도 한 원인입니다.\n형상관리도구도 일단 적응하면 없이는 개발하기 힘들다고 하듯, 이슈 트래커도 꼭 도입을 해야 하는 유용한 도구라고 생각합니다. 다만 초기 적응 기간동안 학습 비용과 효율 저하는 감수를 해야 합니다. 하지만 그 기간이 그리 길지는 않습니다.\n형상관리도구를 사용하고 계신다면 꼭 이슈 트래커도 도입해서 사용 해 보시길 추천 해드립니다. 다만, 형상관리도구를 사용하지 않는데 둘 다 동시에 도입하는 것은 추천하지 않습니다.\n","permalink":"https://sangheonhan.github.io/%ED%8A%B8%EB%9E%99trac-%EB%8F%84%EC%9E%85%EA%B8%B0/","summary":"이슈 트래커(Issue Tracker)인 트랙(Trac)을 어떻게 사내에 도입하게 됐고 그것으로 인한 효과와 구성원들에 대한 반응을 기록한 것입니다. 트위","title":"트랙(Trac) 도입기"},{"content":"이번에도 스트레스에 지친 두뇌를 쉬게(?) 하기 위해 풀어본 심심풀이 프로그래밍 문제입니다.\n연속으로 주어진 숫자들이 n개 있으면 이 숫자들의 간격이 1부터 n-1까지 종류별로 모두 있는 경우를 졸리 점퍼(Jolly jumper)라고 부른다. 예를 들어 1 4 2 3이라는 4개의 숫자가 있을 때 1과 4의 간격은 3, 4와 2의 간격은 2, 2와 3의 간격은 1로 1에서 3까지 모두 있다.\n숫자 리스트를 입력 받아 졸리 점퍼인지 판단하는 프로그램을 작성하라.\n원 문제 링크 : http://functional.or.kr/node/131\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #! /usr/bin/perl use strict; use warnings; use integer; my @n; my %d; my $a; @n = split \u0026#39;\\s+\u0026#39;, \u0026lt;\u0026gt;; if ( is_jolly_num(@n) ) { print \u0026#34;Jolly.\\n\u0026#34;; } else { print \u0026#34;Not jolly.\\n\u0026#34;; } sub is_jolly_num { my @n = @_; foreach ( @n ) { $d{abs($a - $_)} = 1 if defined($a); $a = $_; } foreach ( 1..(@n - 1) ) { unless ( defined($d{$_}) ) { return 0; } } return 1; } ","permalink":"https://sangheonhan.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EC%A0%9C-%EC%A1%B8%EB%A6%AC-%EC%A0%90%ED%8D%BCjolly-jumper/","summary":"이번에도 스트레스에 지친 두뇌를 쉬게(?) 하기 위해 풀어본 심심풀이 프로그래밍 문제입니다. 연속으로 주어진 숫자들이 n개 있으면 이 숫자들의 간격이 1부터 n-","title":"프로그래밍 문제: 졸리 점퍼(Jolly jumper)"},{"content":"마음이 심난해서 심심풀이로 간단하게 풀만한 프로그래밍 문제가 없을까 검색하다 함수형 언어 포럼에 있는 프로그래밍 문제 게시판을 발견했습니다. 맨 위에 있는 문제 하나를 골라 풀어보았습니다.\n문제는 정수 $n$을 입력하면 짝수인 경우 2로 나누고, 홀수인 경우 $3n + 1$을 해줍니다. $n$이 1이 되면 종료하고 그 리스트를 보여주라는 문제입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #! /usr/bin/perl use strict; use warnings; use integer; my @l; my $n; chomp ($n = \u0026lt;STDIN\u0026gt;); push @l, $n; while ( $n != 1 ) { push @l, $n = ($n % 2) ? $n * 3 + 1 : $n / 2; } print \u0026#34;@l\\n\u0026#34;; ","permalink":"https://sangheonhan.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EC%A0%9C-3n--1/","summary":"마음이 심난해서 심심풀이로 간단하게 풀만한 프로그래밍 문제가 없을까 검색하다 함수형 언어 포럼에 있는 프로그래밍 문제 게시판을 발견했습니다. 맨 위에 있는 문제 하","title":"프로그래밍 문제 : 3n + 1"}]